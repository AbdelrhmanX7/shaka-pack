// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: media_info.proto
// Protobuf C++ Version: 4.25.2

#ifndef GOOGLE_PROTOBUF_INCLUDED_media_5finfo_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_media_5finfo_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025002 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_media_5finfo_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_media_5finfo_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_media_5finfo_2eproto;
namespace shaka {
class MediaInfo;
struct MediaInfoDefaultTypeInternal;
extern MediaInfoDefaultTypeInternal _MediaInfo_default_instance_;
class MediaInfo_AudioCodecSpecificData;
struct MediaInfo_AudioCodecSpecificDataDefaultTypeInternal;
extern MediaInfo_AudioCodecSpecificDataDefaultTypeInternal _MediaInfo_AudioCodecSpecificData_default_instance_;
class MediaInfo_AudioInfo;
struct MediaInfo_AudioInfoDefaultTypeInternal;
extern MediaInfo_AudioInfoDefaultTypeInternal _MediaInfo_AudioInfo_default_instance_;
class MediaInfo_ContentProtectionXml;
struct MediaInfo_ContentProtectionXmlDefaultTypeInternal;
extern MediaInfo_ContentProtectionXmlDefaultTypeInternal _MediaInfo_ContentProtectionXml_default_instance_;
class MediaInfo_ContentProtectionXml_AttributeNameValuePair;
struct MediaInfo_ContentProtectionXml_AttributeNameValuePairDefaultTypeInternal;
extern MediaInfo_ContentProtectionXml_AttributeNameValuePairDefaultTypeInternal _MediaInfo_ContentProtectionXml_AttributeNameValuePair_default_instance_;
class MediaInfo_ContentProtectionXml_Element;
struct MediaInfo_ContentProtectionXml_ElementDefaultTypeInternal;
extern MediaInfo_ContentProtectionXml_ElementDefaultTypeInternal _MediaInfo_ContentProtectionXml_Element_default_instance_;
class MediaInfo_ProtectedContent;
struct MediaInfo_ProtectedContentDefaultTypeInternal;
extern MediaInfo_ProtectedContentDefaultTypeInternal _MediaInfo_ProtectedContent_default_instance_;
class MediaInfo_ProtectedContent_ContentProtectionEntry;
struct MediaInfo_ProtectedContent_ContentProtectionEntryDefaultTypeInternal;
extern MediaInfo_ProtectedContent_ContentProtectionEntryDefaultTypeInternal _MediaInfo_ProtectedContent_ContentProtectionEntry_default_instance_;
class MediaInfo_TextInfo;
struct MediaInfo_TextInfoDefaultTypeInternal;
extern MediaInfo_TextInfoDefaultTypeInternal _MediaInfo_TextInfo_default_instance_;
class MediaInfo_VideoInfo;
struct MediaInfo_VideoInfoDefaultTypeInternal;
extern MediaInfo_VideoInfoDefaultTypeInternal _MediaInfo_VideoInfo_default_instance_;
class Range;
struct RangeDefaultTypeInternal;
extern RangeDefaultTypeInternal _Range_default_instance_;
}  // namespace shaka
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace shaka {
enum MediaInfo_TextInfo_TextType : int {
  MediaInfo_TextInfo_TextType_UNKNOWN = 0,
  MediaInfo_TextInfo_TextType_CAPTION = 1,
  MediaInfo_TextInfo_TextType_SUBTITLE = 2,
};

bool MediaInfo_TextInfo_TextType_IsValid(int value);
extern const uint32_t MediaInfo_TextInfo_TextType_internal_data_[];
constexpr MediaInfo_TextInfo_TextType MediaInfo_TextInfo_TextType_TextType_MIN = static_cast<MediaInfo_TextInfo_TextType>(0);
constexpr MediaInfo_TextInfo_TextType MediaInfo_TextInfo_TextType_TextType_MAX = static_cast<MediaInfo_TextInfo_TextType>(2);
constexpr int MediaInfo_TextInfo_TextType_TextType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
MediaInfo_TextInfo_TextType_descriptor();
template <typename T>
const std::string& MediaInfo_TextInfo_TextType_Name(T value) {
  static_assert(std::is_same<T, MediaInfo_TextInfo_TextType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TextType_Name().");
  return MediaInfo_TextInfo_TextType_Name(static_cast<MediaInfo_TextInfo_TextType>(value));
}
template <>
inline const std::string& MediaInfo_TextInfo_TextType_Name(MediaInfo_TextInfo_TextType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MediaInfo_TextInfo_TextType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool MediaInfo_TextInfo_TextType_Parse(absl::string_view name, MediaInfo_TextInfo_TextType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MediaInfo_TextInfo_TextType>(
      MediaInfo_TextInfo_TextType_descriptor(), name, value);
}
enum MediaInfo_ContainerType : int {
  MediaInfo_ContainerType_CONTAINER_UNKNOWN = 0,
  MediaInfo_ContainerType_CONTAINER_MP4 = 1,
  MediaInfo_ContainerType_CONTAINER_MPEG2_TS = 2,
  MediaInfo_ContainerType_CONTAINER_WEBM = 3,
  MediaInfo_ContainerType_CONTAINER_TEXT = 4,
  MediaInfo_ContainerType_CONTAINER_PACKED_AUDIO = 5,
};

bool MediaInfo_ContainerType_IsValid(int value);
extern const uint32_t MediaInfo_ContainerType_internal_data_[];
constexpr MediaInfo_ContainerType MediaInfo_ContainerType_ContainerType_MIN = static_cast<MediaInfo_ContainerType>(0);
constexpr MediaInfo_ContainerType MediaInfo_ContainerType_ContainerType_MAX = static_cast<MediaInfo_ContainerType>(5);
constexpr int MediaInfo_ContainerType_ContainerType_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
MediaInfo_ContainerType_descriptor();
template <typename T>
const std::string& MediaInfo_ContainerType_Name(T value) {
  static_assert(std::is_same<T, MediaInfo_ContainerType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ContainerType_Name().");
  return MediaInfo_ContainerType_Name(static_cast<MediaInfo_ContainerType>(value));
}
template <>
inline const std::string& MediaInfo_ContainerType_Name(MediaInfo_ContainerType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MediaInfo_ContainerType_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool MediaInfo_ContainerType_Parse(absl::string_view name, MediaInfo_ContainerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MediaInfo_ContainerType>(
      MediaInfo_ContainerType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Range final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:shaka.Range) */ {
 public:
  inline Range() : Range(nullptr) {}
  ~Range() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Range(::google::protobuf::internal::ConstantInitialized);

  inline Range(const Range& from)
      : Range(nullptr, from) {}
  Range(Range&& from) noexcept
    : Range() {
    *this = ::std::move(from);
  }

  inline Range& operator=(const Range& from) {
    CopyFrom(from);
    return *this;
  }
  inline Range& operator=(Range&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Range& default_instance() {
    return *internal_default_instance();
  }
  static inline const Range* internal_default_instance() {
    return reinterpret_cast<const Range*>(
               &_Range_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Range& a, Range& b) {
    a.Swap(&b);
  }
  inline void Swap(Range* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Range* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Range* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Range>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Range& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Range& from) {
    Range::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Range* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "shaka.Range";
  }
  protected:
  explicit Range(::google::protobuf::Arena* arena);
  Range(::google::protobuf::Arena* arena, const Range& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBeginFieldNumber = 1,
    kEndFieldNumber = 2,
  };
  // optional uint64 begin = 1;
  bool has_begin() const;
  void clear_begin() ;
  ::uint64_t begin() const;
  void set_begin(::uint64_t value);

  private:
  ::uint64_t _internal_begin() const;
  void _internal_set_begin(::uint64_t value);

  public:
  // optional uint64 end = 2;
  bool has_end() const;
  void clear_end() ;
  ::uint64_t end() const;
  void set_end(::uint64_t value);

  private:
  ::uint64_t _internal_end() const;
  void _internal_set_end(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:shaka.Range)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t begin_;
    ::uint64_t end_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_media_5finfo_2eproto;
};// -------------------------------------------------------------------

class MediaInfo_VideoInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:shaka.MediaInfo.VideoInfo) */ {
 public:
  inline MediaInfo_VideoInfo() : MediaInfo_VideoInfo(nullptr) {}
  ~MediaInfo_VideoInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MediaInfo_VideoInfo(::google::protobuf::internal::ConstantInitialized);

  inline MediaInfo_VideoInfo(const MediaInfo_VideoInfo& from)
      : MediaInfo_VideoInfo(nullptr, from) {}
  MediaInfo_VideoInfo(MediaInfo_VideoInfo&& from) noexcept
    : MediaInfo_VideoInfo() {
    *this = ::std::move(from);
  }

  inline MediaInfo_VideoInfo& operator=(const MediaInfo_VideoInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MediaInfo_VideoInfo& operator=(MediaInfo_VideoInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MediaInfo_VideoInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MediaInfo_VideoInfo* internal_default_instance() {
    return reinterpret_cast<const MediaInfo_VideoInfo*>(
               &_MediaInfo_VideoInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MediaInfo_VideoInfo& a, MediaInfo_VideoInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MediaInfo_VideoInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MediaInfo_VideoInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MediaInfo_VideoInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MediaInfo_VideoInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MediaInfo_VideoInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MediaInfo_VideoInfo& from) {
    MediaInfo_VideoInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MediaInfo_VideoInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "shaka.MediaInfo.VideoInfo";
  }
  protected:
  explicit MediaInfo_VideoInfo(::google::protobuf::Arena* arena);
  MediaInfo_VideoInfo(::google::protobuf::Arena* arena, const MediaInfo_VideoInfo& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodecFieldNumber = 1,
    kDecoderConfigFieldNumber = 6,
    kSupplementalCodecFieldNumber = 13,
    kWidthFieldNumber = 2,
    kHeightFieldNumber = 3,
    kFrameDurationFieldNumber = 5,
    kTimeScaleFieldNumber = 4,
    kPixelWidthFieldNumber = 7,
    kPixelHeightFieldNumber = 8,
    kPlaybackRateFieldNumber = 9,
    kTransferCharacteristicsFieldNumber = 10,
    kColorPrimariesFieldNumber = 11,
    kMatrixCoefficientsFieldNumber = 12,
    kCompatibleBrandFieldNumber = 14,
  };
  // optional string codec = 1;
  bool has_codec() const;
  void clear_codec() ;
  const std::string& codec() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_codec(Arg_&& arg, Args_... args);
  std::string* mutable_codec();
  PROTOBUF_NODISCARD std::string* release_codec();
  void set_allocated_codec(std::string* value);

  private:
  const std::string& _internal_codec() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_codec(
      const std::string& value);
  std::string* _internal_mutable_codec();

  public:
  // optional bytes decoder_config = 6;
  bool has_decoder_config() const;
  void clear_decoder_config() ;
  const std::string& decoder_config() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_decoder_config(Arg_&& arg, Args_... args);
  std::string* mutable_decoder_config();
  PROTOBUF_NODISCARD std::string* release_decoder_config();
  void set_allocated_decoder_config(std::string* value);

  private:
  const std::string& _internal_decoder_config() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_decoder_config(
      const std::string& value);
  std::string* _internal_mutable_decoder_config();

  public:
  // optional string supplemental_codec = 13;
  bool has_supplemental_codec() const;
  void clear_supplemental_codec() ;
  const std::string& supplemental_codec() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_supplemental_codec(Arg_&& arg, Args_... args);
  std::string* mutable_supplemental_codec();
  PROTOBUF_NODISCARD std::string* release_supplemental_codec();
  void set_allocated_supplemental_codec(std::string* value);

  private:
  const std::string& _internal_supplemental_codec() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_supplemental_codec(
      const std::string& value);
  std::string* _internal_mutable_supplemental_codec();

  public:
  // optional uint32 width = 2;
  bool has_width() const;
  void clear_width() ;
  ::uint32_t width() const;
  void set_width(::uint32_t value);

  private:
  ::uint32_t _internal_width() const;
  void _internal_set_width(::uint32_t value);

  public:
  // optional uint32 height = 3;
  bool has_height() const;
  void clear_height() ;
  ::uint32_t height() const;
  void set_height(::uint32_t value);

  private:
  ::uint32_t _internal_height() const;
  void _internal_set_height(::uint32_t value);

  public:
  // optional uint64 frame_duration = 5;
  bool has_frame_duration() const;
  void clear_frame_duration() ;
  ::uint64_t frame_duration() const;
  void set_frame_duration(::uint64_t value);

  private:
  ::uint64_t _internal_frame_duration() const;
  void _internal_set_frame_duration(::uint64_t value);

  public:
  // optional uint32 time_scale = 4;
  bool has_time_scale() const;
  void clear_time_scale() ;
  ::uint32_t time_scale() const;
  void set_time_scale(::uint32_t value);

  private:
  ::uint32_t _internal_time_scale() const;
  void _internal_set_time_scale(::uint32_t value);

  public:
  // optional uint32 pixel_width = 7;
  bool has_pixel_width() const;
  void clear_pixel_width() ;
  ::uint32_t pixel_width() const;
  void set_pixel_width(::uint32_t value);

  private:
  ::uint32_t _internal_pixel_width() const;
  void _internal_set_pixel_width(::uint32_t value);

  public:
  // optional uint32 pixel_height = 8;
  bool has_pixel_height() const;
  void clear_pixel_height() ;
  ::uint32_t pixel_height() const;
  void set_pixel_height(::uint32_t value);

  private:
  ::uint32_t _internal_pixel_height() const;
  void _internal_set_pixel_height(::uint32_t value);

  public:
  // optional uint32 playback_rate = 9;
  bool has_playback_rate() const;
  void clear_playback_rate() ;
  ::uint32_t playback_rate() const;
  void set_playback_rate(::uint32_t value);

  private:
  ::uint32_t _internal_playback_rate() const;
  void _internal_set_playback_rate(::uint32_t value);

  public:
  // optional uint32 transfer_characteristics = 10;
  bool has_transfer_characteristics() const;
  void clear_transfer_characteristics() ;
  ::uint32_t transfer_characteristics() const;
  void set_transfer_characteristics(::uint32_t value);

  private:
  ::uint32_t _internal_transfer_characteristics() const;
  void _internal_set_transfer_characteristics(::uint32_t value);

  public:
  // optional uint32 color_primaries = 11;
  bool has_color_primaries() const;
  void clear_color_primaries() ;
  ::uint32_t color_primaries() const;
  void set_color_primaries(::uint32_t value);

  private:
  ::uint32_t _internal_color_primaries() const;
  void _internal_set_color_primaries(::uint32_t value);

  public:
  // optional uint32 matrix_coefficients = 12;
  bool has_matrix_coefficients() const;
  void clear_matrix_coefficients() ;
  ::uint32_t matrix_coefficients() const;
  void set_matrix_coefficients(::uint32_t value);

  private:
  ::uint32_t _internal_matrix_coefficients() const;
  void _internal_set_matrix_coefficients(::uint32_t value);

  public:
  // optional uint32 compatible_brand = 14;
  bool has_compatible_brand() const;
  void clear_compatible_brand() ;
  ::uint32_t compatible_brand() const;
  void set_compatible_brand(::uint32_t value);

  private:
  ::uint32_t _internal_compatible_brand() const;
  void _internal_set_compatible_brand(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:shaka.MediaInfo.VideoInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 14, 0,
      65, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr codec_;
    ::google::protobuf::internal::ArenaStringPtr decoder_config_;
    ::google::protobuf::internal::ArenaStringPtr supplemental_codec_;
    ::uint32_t width_;
    ::uint32_t height_;
    ::uint64_t frame_duration_;
    ::uint32_t time_scale_;
    ::uint32_t pixel_width_;
    ::uint32_t pixel_height_;
    ::uint32_t playback_rate_;
    ::uint32_t transfer_characteristics_;
    ::uint32_t color_primaries_;
    ::uint32_t matrix_coefficients_;
    ::uint32_t compatible_brand_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_media_5finfo_2eproto;
};// -------------------------------------------------------------------

class MediaInfo_TextInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:shaka.MediaInfo.TextInfo) */ {
 public:
  inline MediaInfo_TextInfo() : MediaInfo_TextInfo(nullptr) {}
  ~MediaInfo_TextInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MediaInfo_TextInfo(::google::protobuf::internal::ConstantInitialized);

  inline MediaInfo_TextInfo(const MediaInfo_TextInfo& from)
      : MediaInfo_TextInfo(nullptr, from) {}
  MediaInfo_TextInfo(MediaInfo_TextInfo&& from) noexcept
    : MediaInfo_TextInfo() {
    *this = ::std::move(from);
  }

  inline MediaInfo_TextInfo& operator=(const MediaInfo_TextInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MediaInfo_TextInfo& operator=(MediaInfo_TextInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MediaInfo_TextInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MediaInfo_TextInfo* internal_default_instance() {
    return reinterpret_cast<const MediaInfo_TextInfo*>(
               &_MediaInfo_TextInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(MediaInfo_TextInfo& a, MediaInfo_TextInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MediaInfo_TextInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MediaInfo_TextInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MediaInfo_TextInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MediaInfo_TextInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MediaInfo_TextInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MediaInfo_TextInfo& from) {
    MediaInfo_TextInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MediaInfo_TextInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "shaka.MediaInfo.TextInfo";
  }
  protected:
  explicit MediaInfo_TextInfo(::google::protobuf::Arena* arena);
  MediaInfo_TextInfo(::google::protobuf::Arena* arena, const MediaInfo_TextInfo& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using TextType = MediaInfo_TextInfo_TextType;
  static constexpr TextType UNKNOWN = MediaInfo_TextInfo_TextType_UNKNOWN;
  static constexpr TextType CAPTION = MediaInfo_TextInfo_TextType_CAPTION;
  static constexpr TextType SUBTITLE = MediaInfo_TextInfo_TextType_SUBTITLE;
  static inline bool TextType_IsValid(int value) {
    return MediaInfo_TextInfo_TextType_IsValid(value);
  }
  static constexpr TextType TextType_MIN = MediaInfo_TextInfo_TextType_TextType_MIN;
  static constexpr TextType TextType_MAX = MediaInfo_TextInfo_TextType_TextType_MAX;
  static constexpr int TextType_ARRAYSIZE = MediaInfo_TextInfo_TextType_TextType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* TextType_descriptor() {
    return MediaInfo_TextInfo_TextType_descriptor();
  }
  template <typename T>
  static inline const std::string& TextType_Name(T value) {
    return MediaInfo_TextInfo_TextType_Name(value);
  }
  static inline bool TextType_Parse(absl::string_view name, TextType* value) {
    return MediaInfo_TextInfo_TextType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCodecFieldNumber = 1,
    kLanguageFieldNumber = 2,
    kTypeFieldNumber = 3,
  };
  // optional string codec = 1;
  bool has_codec() const;
  void clear_codec() ;
  const std::string& codec() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_codec(Arg_&& arg, Args_... args);
  std::string* mutable_codec();
  PROTOBUF_NODISCARD std::string* release_codec();
  void set_allocated_codec(std::string* value);

  private:
  const std::string& _internal_codec() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_codec(
      const std::string& value);
  std::string* _internal_mutable_codec();

  public:
  // optional string language = 2;
  bool has_language() const;
  void clear_language() ;
  const std::string& language() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_language(Arg_&& arg, Args_... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* value);

  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(
      const std::string& value);
  std::string* _internal_mutable_language();

  public:
  // optional .shaka.MediaInfo.TextInfo.TextType type = 3;
  bool has_type() const;
  void clear_type() ;
  ::shaka::MediaInfo_TextInfo_TextType type() const;
  void set_type(::shaka::MediaInfo_TextInfo_TextType value);

  private:
  ::shaka::MediaInfo_TextInfo_TextType _internal_type() const;
  void _internal_set_type(::shaka::MediaInfo_TextInfo_TextType value);

  public:
  // @@protoc_insertion_point(class_scope:shaka.MediaInfo.TextInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      46, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr codec_;
    ::google::protobuf::internal::ArenaStringPtr language_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_media_5finfo_2eproto;
};// -------------------------------------------------------------------

class MediaInfo_ProtectedContent_ContentProtectionEntry final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:shaka.MediaInfo.ProtectedContent.ContentProtectionEntry) */ {
 public:
  inline MediaInfo_ProtectedContent_ContentProtectionEntry() : MediaInfo_ProtectedContent_ContentProtectionEntry(nullptr) {}
  ~MediaInfo_ProtectedContent_ContentProtectionEntry() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MediaInfo_ProtectedContent_ContentProtectionEntry(::google::protobuf::internal::ConstantInitialized);

  inline MediaInfo_ProtectedContent_ContentProtectionEntry(const MediaInfo_ProtectedContent_ContentProtectionEntry& from)
      : MediaInfo_ProtectedContent_ContentProtectionEntry(nullptr, from) {}
  MediaInfo_ProtectedContent_ContentProtectionEntry(MediaInfo_ProtectedContent_ContentProtectionEntry&& from) noexcept
    : MediaInfo_ProtectedContent_ContentProtectionEntry() {
    *this = ::std::move(from);
  }

  inline MediaInfo_ProtectedContent_ContentProtectionEntry& operator=(const MediaInfo_ProtectedContent_ContentProtectionEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline MediaInfo_ProtectedContent_ContentProtectionEntry& operator=(MediaInfo_ProtectedContent_ContentProtectionEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MediaInfo_ProtectedContent_ContentProtectionEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const MediaInfo_ProtectedContent_ContentProtectionEntry* internal_default_instance() {
    return reinterpret_cast<const MediaInfo_ProtectedContent_ContentProtectionEntry*>(
               &_MediaInfo_ProtectedContent_ContentProtectionEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MediaInfo_ProtectedContent_ContentProtectionEntry& a, MediaInfo_ProtectedContent_ContentProtectionEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(MediaInfo_ProtectedContent_ContentProtectionEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MediaInfo_ProtectedContent_ContentProtectionEntry* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MediaInfo_ProtectedContent_ContentProtectionEntry* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MediaInfo_ProtectedContent_ContentProtectionEntry>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MediaInfo_ProtectedContent_ContentProtectionEntry& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MediaInfo_ProtectedContent_ContentProtectionEntry& from) {
    MediaInfo_ProtectedContent_ContentProtectionEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MediaInfo_ProtectedContent_ContentProtectionEntry* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "shaka.MediaInfo.ProtectedContent.ContentProtectionEntry";
  }
  protected:
  explicit MediaInfo_ProtectedContent_ContentProtectionEntry(::google::protobuf::Arena* arena);
  MediaInfo_ProtectedContent_ContentProtectionEntry(::google::protobuf::Arena* arena, const MediaInfo_ProtectedContent_ContentProtectionEntry& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUuidFieldNumber = 1,
    kNameVersionFieldNumber = 2,
    kPsshFieldNumber = 3,
  };
  // optional string uuid = 1;
  bool has_uuid() const;
  void clear_uuid() ;
  const std::string& uuid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uuid(Arg_&& arg, Args_... args);
  std::string* mutable_uuid();
  PROTOBUF_NODISCARD std::string* release_uuid();
  void set_allocated_uuid(std::string* value);

  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(
      const std::string& value);
  std::string* _internal_mutable_uuid();

  public:
  // optional string name_version = 2;
  bool has_name_version() const;
  void clear_name_version() ;
  const std::string& name_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name_version(Arg_&& arg, Args_... args);
  std::string* mutable_name_version();
  PROTOBUF_NODISCARD std::string* release_name_version();
  void set_allocated_name_version(std::string* value);

  private:
  const std::string& _internal_name_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name_version(
      const std::string& value);
  std::string* _internal_mutable_name_version();

  public:
  // optional bytes pssh = 3;
  bool has_pssh() const;
  void clear_pssh() ;
  const std::string& pssh() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pssh(Arg_&& arg, Args_... args);
  std::string* mutable_pssh();
  PROTOBUF_NODISCARD std::string* release_pssh();
  void set_allocated_pssh(std::string* value);

  private:
  const std::string& _internal_pssh() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pssh(
      const std::string& value);
  std::string* _internal_mutable_pssh();

  public:
  // @@protoc_insertion_point(class_scope:shaka.MediaInfo.ProtectedContent.ContentProtectionEntry)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      80, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr uuid_;
    ::google::protobuf::internal::ArenaStringPtr name_version_;
    ::google::protobuf::internal::ArenaStringPtr pssh_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_media_5finfo_2eproto;
};// -------------------------------------------------------------------

class MediaInfo_ContentProtectionXml_AttributeNameValuePair final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:shaka.MediaInfo.ContentProtectionXml.AttributeNameValuePair) */ {
 public:
  inline MediaInfo_ContentProtectionXml_AttributeNameValuePair() : MediaInfo_ContentProtectionXml_AttributeNameValuePair(nullptr) {}
  ~MediaInfo_ContentProtectionXml_AttributeNameValuePair() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MediaInfo_ContentProtectionXml_AttributeNameValuePair(::google::protobuf::internal::ConstantInitialized);

  inline MediaInfo_ContentProtectionXml_AttributeNameValuePair(const MediaInfo_ContentProtectionXml_AttributeNameValuePair& from)
      : MediaInfo_ContentProtectionXml_AttributeNameValuePair(nullptr, from) {}
  MediaInfo_ContentProtectionXml_AttributeNameValuePair(MediaInfo_ContentProtectionXml_AttributeNameValuePair&& from) noexcept
    : MediaInfo_ContentProtectionXml_AttributeNameValuePair() {
    *this = ::std::move(from);
  }

  inline MediaInfo_ContentProtectionXml_AttributeNameValuePair& operator=(const MediaInfo_ContentProtectionXml_AttributeNameValuePair& from) {
    CopyFrom(from);
    return *this;
  }
  inline MediaInfo_ContentProtectionXml_AttributeNameValuePair& operator=(MediaInfo_ContentProtectionXml_AttributeNameValuePair&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MediaInfo_ContentProtectionXml_AttributeNameValuePair& default_instance() {
    return *internal_default_instance();
  }
  static inline const MediaInfo_ContentProtectionXml_AttributeNameValuePair* internal_default_instance() {
    return reinterpret_cast<const MediaInfo_ContentProtectionXml_AttributeNameValuePair*>(
               &_MediaInfo_ContentProtectionXml_AttributeNameValuePair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MediaInfo_ContentProtectionXml_AttributeNameValuePair& a, MediaInfo_ContentProtectionXml_AttributeNameValuePair& b) {
    a.Swap(&b);
  }
  inline void Swap(MediaInfo_ContentProtectionXml_AttributeNameValuePair* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MediaInfo_ContentProtectionXml_AttributeNameValuePair* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MediaInfo_ContentProtectionXml_AttributeNameValuePair* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MediaInfo_ContentProtectionXml_AttributeNameValuePair>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MediaInfo_ContentProtectionXml_AttributeNameValuePair& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MediaInfo_ContentProtectionXml_AttributeNameValuePair& from) {
    MediaInfo_ContentProtectionXml_AttributeNameValuePair::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MediaInfo_ContentProtectionXml_AttributeNameValuePair* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "shaka.MediaInfo.ContentProtectionXml.AttributeNameValuePair";
  }
  protected:
  explicit MediaInfo_ContentProtectionXml_AttributeNameValuePair(::google::protobuf::Arena* arena);
  MediaInfo_ContentProtectionXml_AttributeNameValuePair(::google::protobuf::Arena* arena, const MediaInfo_ContentProtectionXml_AttributeNameValuePair& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // optional string name = 1;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // optional string value = 2;
  bool has_value() const;
  void clear_value() ;
  const std::string& value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // @@protoc_insertion_point(class_scope:shaka.MediaInfo.ContentProtectionXml.AttributeNameValuePair)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      77, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_media_5finfo_2eproto;
};// -------------------------------------------------------------------

class MediaInfo_AudioCodecSpecificData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:shaka.MediaInfo.AudioCodecSpecificData) */ {
 public:
  inline MediaInfo_AudioCodecSpecificData() : MediaInfo_AudioCodecSpecificData(nullptr) {}
  ~MediaInfo_AudioCodecSpecificData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MediaInfo_AudioCodecSpecificData(::google::protobuf::internal::ConstantInitialized);

  inline MediaInfo_AudioCodecSpecificData(const MediaInfo_AudioCodecSpecificData& from)
      : MediaInfo_AudioCodecSpecificData(nullptr, from) {}
  MediaInfo_AudioCodecSpecificData(MediaInfo_AudioCodecSpecificData&& from) noexcept
    : MediaInfo_AudioCodecSpecificData() {
    *this = ::std::move(from);
  }

  inline MediaInfo_AudioCodecSpecificData& operator=(const MediaInfo_AudioCodecSpecificData& from) {
    CopyFrom(from);
    return *this;
  }
  inline MediaInfo_AudioCodecSpecificData& operator=(MediaInfo_AudioCodecSpecificData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MediaInfo_AudioCodecSpecificData& default_instance() {
    return *internal_default_instance();
  }
  static inline const MediaInfo_AudioCodecSpecificData* internal_default_instance() {
    return reinterpret_cast<const MediaInfo_AudioCodecSpecificData*>(
               &_MediaInfo_AudioCodecSpecificData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MediaInfo_AudioCodecSpecificData& a, MediaInfo_AudioCodecSpecificData& b) {
    a.Swap(&b);
  }
  inline void Swap(MediaInfo_AudioCodecSpecificData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MediaInfo_AudioCodecSpecificData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MediaInfo_AudioCodecSpecificData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MediaInfo_AudioCodecSpecificData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MediaInfo_AudioCodecSpecificData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MediaInfo_AudioCodecSpecificData& from) {
    MediaInfo_AudioCodecSpecificData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MediaInfo_AudioCodecSpecificData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "shaka.MediaInfo.AudioCodecSpecificData";
  }
  protected:
  explicit MediaInfo_AudioCodecSpecificData(::google::protobuf::Arena* arena);
  MediaInfo_AudioCodecSpecificData(::google::protobuf::Arena* arena, const MediaInfo_AudioCodecSpecificData& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelMaskFieldNumber = 1,
    kChannelMpegValueFieldNumber = 2,
    kEc3JocComplexityFieldNumber = 3,
    kAc4ImsFlagFieldNumber = 4,
    kAc4CbiFlagFieldNumber = 5,
  };
  // optional uint32 channel_mask = 1;
  bool has_channel_mask() const;
  void clear_channel_mask() ;
  ::uint32_t channel_mask() const;
  void set_channel_mask(::uint32_t value);

  private:
  ::uint32_t _internal_channel_mask() const;
  void _internal_set_channel_mask(::uint32_t value);

  public:
  // optional uint32 channel_mpeg_value = 2;
  bool has_channel_mpeg_value() const;
  void clear_channel_mpeg_value() ;
  ::uint32_t channel_mpeg_value() const;
  void set_channel_mpeg_value(::uint32_t value);

  private:
  ::uint32_t _internal_channel_mpeg_value() const;
  void _internal_set_channel_mpeg_value(::uint32_t value);

  public:
  // optional uint32 ec3_joc_complexity = 3;
  bool has_ec3_joc_complexity() const;
  void clear_ec3_joc_complexity() ;
  ::uint32_t ec3_joc_complexity() const;
  void set_ec3_joc_complexity(::uint32_t value);

  private:
  ::uint32_t _internal_ec3_joc_complexity() const;
  void _internal_set_ec3_joc_complexity(::uint32_t value);

  public:
  // optional bool ac4_ims_flag = 4;
  bool has_ac4_ims_flag() const;
  void clear_ac4_ims_flag() ;
  bool ac4_ims_flag() const;
  void set_ac4_ims_flag(bool value);

  private:
  bool _internal_ac4_ims_flag() const;
  void _internal_set_ac4_ims_flag(bool value);

  public:
  // optional bool ac4_cbi_flag = 5;
  bool has_ac4_cbi_flag() const;
  void clear_ac4_cbi_flag() ;
  bool ac4_cbi_flag() const;
  void set_ac4_cbi_flag(bool value);

  private:
  bool _internal_ac4_cbi_flag() const;
  void _internal_set_ac4_cbi_flag(bool value);

  public:
  // @@protoc_insertion_point(class_scope:shaka.MediaInfo.AudioCodecSpecificData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t channel_mask_;
    ::uint32_t channel_mpeg_value_;
    ::uint32_t ec3_joc_complexity_;
    bool ac4_ims_flag_;
    bool ac4_cbi_flag_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_media_5finfo_2eproto;
};// -------------------------------------------------------------------

class MediaInfo_ProtectedContent final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:shaka.MediaInfo.ProtectedContent) */ {
 public:
  inline MediaInfo_ProtectedContent() : MediaInfo_ProtectedContent(nullptr) {}
  ~MediaInfo_ProtectedContent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MediaInfo_ProtectedContent(::google::protobuf::internal::ConstantInitialized);

  inline MediaInfo_ProtectedContent(const MediaInfo_ProtectedContent& from)
      : MediaInfo_ProtectedContent(nullptr, from) {}
  MediaInfo_ProtectedContent(MediaInfo_ProtectedContent&& from) noexcept
    : MediaInfo_ProtectedContent() {
    *this = ::std::move(from);
  }

  inline MediaInfo_ProtectedContent& operator=(const MediaInfo_ProtectedContent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MediaInfo_ProtectedContent& operator=(MediaInfo_ProtectedContent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MediaInfo_ProtectedContent& default_instance() {
    return *internal_default_instance();
  }
  static inline const MediaInfo_ProtectedContent* internal_default_instance() {
    return reinterpret_cast<const MediaInfo_ProtectedContent*>(
               &_MediaInfo_ProtectedContent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MediaInfo_ProtectedContent& a, MediaInfo_ProtectedContent& b) {
    a.Swap(&b);
  }
  inline void Swap(MediaInfo_ProtectedContent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MediaInfo_ProtectedContent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MediaInfo_ProtectedContent* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MediaInfo_ProtectedContent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MediaInfo_ProtectedContent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MediaInfo_ProtectedContent& from) {
    MediaInfo_ProtectedContent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MediaInfo_ProtectedContent* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "shaka.MediaInfo.ProtectedContent";
  }
  protected:
  explicit MediaInfo_ProtectedContent(::google::protobuf::Arena* arena);
  MediaInfo_ProtectedContent(::google::protobuf::Arena* arena, const MediaInfo_ProtectedContent& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using ContentProtectionEntry = MediaInfo_ProtectedContent_ContentProtectionEntry;

  // accessors -------------------------------------------------------

  enum : int {
    kContentProtectionEntryFieldNumber = 2,
    kDefaultKeyIdFieldNumber = 1,
    kProtectionSchemeFieldNumber = 3,
    kIncludeMsprProFieldNumber = 4,
  };
  // repeated .shaka.MediaInfo.ProtectedContent.ContentProtectionEntry content_protection_entry = 2;
  int content_protection_entry_size() const;
  private:
  int _internal_content_protection_entry_size() const;

  public:
  void clear_content_protection_entry() ;
  ::shaka::MediaInfo_ProtectedContent_ContentProtectionEntry* mutable_content_protection_entry(int index);
  ::google::protobuf::RepeatedPtrField< ::shaka::MediaInfo_ProtectedContent_ContentProtectionEntry >*
      mutable_content_protection_entry();
  private:
  const ::google::protobuf::RepeatedPtrField<::shaka::MediaInfo_ProtectedContent_ContentProtectionEntry>& _internal_content_protection_entry() const;
  ::google::protobuf::RepeatedPtrField<::shaka::MediaInfo_ProtectedContent_ContentProtectionEntry>* _internal_mutable_content_protection_entry();
  public:
  const ::shaka::MediaInfo_ProtectedContent_ContentProtectionEntry& content_protection_entry(int index) const;
  ::shaka::MediaInfo_ProtectedContent_ContentProtectionEntry* add_content_protection_entry();
  const ::google::protobuf::RepeatedPtrField< ::shaka::MediaInfo_ProtectedContent_ContentProtectionEntry >&
      content_protection_entry() const;
  // optional bytes default_key_id = 1;
  bool has_default_key_id() const;
  void clear_default_key_id() ;
  const std::string& default_key_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_default_key_id(Arg_&& arg, Args_... args);
  std::string* mutable_default_key_id();
  PROTOBUF_NODISCARD std::string* release_default_key_id();
  void set_allocated_default_key_id(std::string* value);

  private:
  const std::string& _internal_default_key_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_key_id(
      const std::string& value);
  std::string* _internal_mutable_default_key_id();

  public:
  // optional string protection_scheme = 3 [default = "cenc"];
  bool has_protection_scheme() const;
  void clear_protection_scheme() ;
  const std::string& protection_scheme() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_protection_scheme(Arg_&& arg, Args_... args);
  std::string* mutable_protection_scheme();
  PROTOBUF_NODISCARD std::string* release_protection_scheme();
  void set_allocated_protection_scheme(std::string* value);

  private:
  const std::string& _internal_protection_scheme() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_protection_scheme(
      const std::string& value);
  std::string* _internal_mutable_protection_scheme();

  public:
  // optional bool include_mspr_pro = 4 [default = true];
  bool has_include_mspr_pro() const;
  void clear_include_mspr_pro() ;
  bool include_mspr_pro() const;
  void set_include_mspr_pro(bool value);

  private:
  bool _internal_include_mspr_pro() const;
  void _internal_set_include_mspr_pro(bool value);

  public:
  // @@protoc_insertion_point(class_scope:shaka.MediaInfo.ProtectedContent)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      58, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::shaka::MediaInfo_ProtectedContent_ContentProtectionEntry > content_protection_entry_;
    ::google::protobuf::internal::ArenaStringPtr default_key_id_;
    static const ::google::protobuf::internal::LazyString _i_give_permission_to_break_this_code_default_protection_scheme_;
    ::google::protobuf::internal::ArenaStringPtr protection_scheme_;
    bool include_mspr_pro_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_media_5finfo_2eproto;
};// -------------------------------------------------------------------

class MediaInfo_ContentProtectionXml_Element final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:shaka.MediaInfo.ContentProtectionXml.Element) */ {
 public:
  inline MediaInfo_ContentProtectionXml_Element() : MediaInfo_ContentProtectionXml_Element(nullptr) {}
  ~MediaInfo_ContentProtectionXml_Element() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MediaInfo_ContentProtectionXml_Element(::google::protobuf::internal::ConstantInitialized);

  inline MediaInfo_ContentProtectionXml_Element(const MediaInfo_ContentProtectionXml_Element& from)
      : MediaInfo_ContentProtectionXml_Element(nullptr, from) {}
  MediaInfo_ContentProtectionXml_Element(MediaInfo_ContentProtectionXml_Element&& from) noexcept
    : MediaInfo_ContentProtectionXml_Element() {
    *this = ::std::move(from);
  }

  inline MediaInfo_ContentProtectionXml_Element& operator=(const MediaInfo_ContentProtectionXml_Element& from) {
    CopyFrom(from);
    return *this;
  }
  inline MediaInfo_ContentProtectionXml_Element& operator=(MediaInfo_ContentProtectionXml_Element&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MediaInfo_ContentProtectionXml_Element& default_instance() {
    return *internal_default_instance();
  }
  static inline const MediaInfo_ContentProtectionXml_Element* internal_default_instance() {
    return reinterpret_cast<const MediaInfo_ContentProtectionXml_Element*>(
               &_MediaInfo_ContentProtectionXml_Element_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(MediaInfo_ContentProtectionXml_Element& a, MediaInfo_ContentProtectionXml_Element& b) {
    a.Swap(&b);
  }
  inline void Swap(MediaInfo_ContentProtectionXml_Element* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MediaInfo_ContentProtectionXml_Element* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MediaInfo_ContentProtectionXml_Element* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MediaInfo_ContentProtectionXml_Element>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MediaInfo_ContentProtectionXml_Element& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MediaInfo_ContentProtectionXml_Element& from) {
    MediaInfo_ContentProtectionXml_Element::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MediaInfo_ContentProtectionXml_Element* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "shaka.MediaInfo.ContentProtectionXml.Element";
  }
  protected:
  explicit MediaInfo_ContentProtectionXml_Element(::google::protobuf::Arena* arena);
  MediaInfo_ContentProtectionXml_Element(::google::protobuf::Arena* arena, const MediaInfo_ContentProtectionXml_Element& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 2,
    kSubelementsFieldNumber = 3,
    kNameFieldNumber = 1,
  };
  // repeated .shaka.MediaInfo.ContentProtectionXml.AttributeNameValuePair attributes = 2;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;

  public:
  void clear_attributes() ;
  ::shaka::MediaInfo_ContentProtectionXml_AttributeNameValuePair* mutable_attributes(int index);
  ::google::protobuf::RepeatedPtrField< ::shaka::MediaInfo_ContentProtectionXml_AttributeNameValuePair >*
      mutable_attributes();
  private:
  const ::google::protobuf::RepeatedPtrField<::shaka::MediaInfo_ContentProtectionXml_AttributeNameValuePair>& _internal_attributes() const;
  ::google::protobuf::RepeatedPtrField<::shaka::MediaInfo_ContentProtectionXml_AttributeNameValuePair>* _internal_mutable_attributes();
  public:
  const ::shaka::MediaInfo_ContentProtectionXml_AttributeNameValuePair& attributes(int index) const;
  ::shaka::MediaInfo_ContentProtectionXml_AttributeNameValuePair* add_attributes();
  const ::google::protobuf::RepeatedPtrField< ::shaka::MediaInfo_ContentProtectionXml_AttributeNameValuePair >&
      attributes() const;
  // repeated .shaka.MediaInfo.ContentProtectionXml.Element subelements = 3;
  int subelements_size() const;
  private:
  int _internal_subelements_size() const;

  public:
  void clear_subelements() ;
  ::shaka::MediaInfo_ContentProtectionXml_Element* mutable_subelements(int index);
  ::google::protobuf::RepeatedPtrField< ::shaka::MediaInfo_ContentProtectionXml_Element >*
      mutable_subelements();
  private:
  const ::google::protobuf::RepeatedPtrField<::shaka::MediaInfo_ContentProtectionXml_Element>& _internal_subelements() const;
  ::google::protobuf::RepeatedPtrField<::shaka::MediaInfo_ContentProtectionXml_Element>* _internal_mutable_subelements();
  public:
  const ::shaka::MediaInfo_ContentProtectionXml_Element& subelements(int index) const;
  ::shaka::MediaInfo_ContentProtectionXml_Element* add_subelements();
  const ::google::protobuf::RepeatedPtrField< ::shaka::MediaInfo_ContentProtectionXml_Element >&
      subelements() const;
  // optional string name = 1;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:shaka.MediaInfo.ContentProtectionXml.Element)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      57, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::shaka::MediaInfo_ContentProtectionXml_AttributeNameValuePair > attributes_;
    ::google::protobuf::RepeatedPtrField< ::shaka::MediaInfo_ContentProtectionXml_Element > subelements_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_media_5finfo_2eproto;
};// -------------------------------------------------------------------

class MediaInfo_AudioInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:shaka.MediaInfo.AudioInfo) */ {
 public:
  inline MediaInfo_AudioInfo() : MediaInfo_AudioInfo(nullptr) {}
  ~MediaInfo_AudioInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MediaInfo_AudioInfo(::google::protobuf::internal::ConstantInitialized);

  inline MediaInfo_AudioInfo(const MediaInfo_AudioInfo& from)
      : MediaInfo_AudioInfo(nullptr, from) {}
  MediaInfo_AudioInfo(MediaInfo_AudioInfo&& from) noexcept
    : MediaInfo_AudioInfo() {
    *this = ::std::move(from);
  }

  inline MediaInfo_AudioInfo& operator=(const MediaInfo_AudioInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MediaInfo_AudioInfo& operator=(MediaInfo_AudioInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MediaInfo_AudioInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MediaInfo_AudioInfo* internal_default_instance() {
    return reinterpret_cast<const MediaInfo_AudioInfo*>(
               &_MediaInfo_AudioInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MediaInfo_AudioInfo& a, MediaInfo_AudioInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MediaInfo_AudioInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MediaInfo_AudioInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MediaInfo_AudioInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MediaInfo_AudioInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MediaInfo_AudioInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MediaInfo_AudioInfo& from) {
    MediaInfo_AudioInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MediaInfo_AudioInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "shaka.MediaInfo.AudioInfo";
  }
  protected:
  explicit MediaInfo_AudioInfo(::google::protobuf::Arena* arena);
  MediaInfo_AudioInfo(::google::protobuf::Arena* arena, const MediaInfo_AudioInfo& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodecFieldNumber = 1,
    kLanguageFieldNumber = 5,
    kDecoderConfigFieldNumber = 6,
    kCodecSpecificDataFieldNumber = 7,
    kSamplingFrequencyFieldNumber = 2,
    kTimeScaleFieldNumber = 3,
    kNumChannelsFieldNumber = 4,
  };
  // optional string codec = 1;
  bool has_codec() const;
  void clear_codec() ;
  const std::string& codec() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_codec(Arg_&& arg, Args_... args);
  std::string* mutable_codec();
  PROTOBUF_NODISCARD std::string* release_codec();
  void set_allocated_codec(std::string* value);

  private:
  const std::string& _internal_codec() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_codec(
      const std::string& value);
  std::string* _internal_mutable_codec();

  public:
  // optional string language = 5;
  bool has_language() const;
  void clear_language() ;
  const std::string& language() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_language(Arg_&& arg, Args_... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* value);

  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(
      const std::string& value);
  std::string* _internal_mutable_language();

  public:
  // optional bytes decoder_config = 6;
  bool has_decoder_config() const;
  void clear_decoder_config() ;
  const std::string& decoder_config() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_decoder_config(Arg_&& arg, Args_... args);
  std::string* mutable_decoder_config();
  PROTOBUF_NODISCARD std::string* release_decoder_config();
  void set_allocated_decoder_config(std::string* value);

  private:
  const std::string& _internal_decoder_config() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_decoder_config(
      const std::string& value);
  std::string* _internal_mutable_decoder_config();

  public:
  // optional .shaka.MediaInfo.AudioCodecSpecificData codec_specific_data = 7;
  bool has_codec_specific_data() const;
  void clear_codec_specific_data() ;
  const ::shaka::MediaInfo_AudioCodecSpecificData& codec_specific_data() const;
  PROTOBUF_NODISCARD ::shaka::MediaInfo_AudioCodecSpecificData* release_codec_specific_data();
  ::shaka::MediaInfo_AudioCodecSpecificData* mutable_codec_specific_data();
  void set_allocated_codec_specific_data(::shaka::MediaInfo_AudioCodecSpecificData* value);
  void unsafe_arena_set_allocated_codec_specific_data(::shaka::MediaInfo_AudioCodecSpecificData* value);
  ::shaka::MediaInfo_AudioCodecSpecificData* unsafe_arena_release_codec_specific_data();

  private:
  const ::shaka::MediaInfo_AudioCodecSpecificData& _internal_codec_specific_data() const;
  ::shaka::MediaInfo_AudioCodecSpecificData* _internal_mutable_codec_specific_data();

  public:
  // optional uint32 sampling_frequency = 2;
  bool has_sampling_frequency() const;
  void clear_sampling_frequency() ;
  ::uint32_t sampling_frequency() const;
  void set_sampling_frequency(::uint32_t value);

  private:
  ::uint32_t _internal_sampling_frequency() const;
  void _internal_set_sampling_frequency(::uint32_t value);

  public:
  // optional uint32 time_scale = 3;
  bool has_time_scale() const;
  void clear_time_scale() ;
  ::uint32_t time_scale() const;
  void set_time_scale(::uint32_t value);

  private:
  ::uint32_t _internal_time_scale() const;
  void _internal_set_time_scale(::uint32_t value);

  public:
  // optional uint32 num_channels = 4;
  bool has_num_channels() const;
  void clear_num_channels() ;
  ::uint32_t num_channels() const;
  void set_num_channels(::uint32_t value);

  private:
  ::uint32_t _internal_num_channels() const;
  void _internal_set_num_channels(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:shaka.MediaInfo.AudioInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 1,
      47, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr codec_;
    ::google::protobuf::internal::ArenaStringPtr language_;
    ::google::protobuf::internal::ArenaStringPtr decoder_config_;
    ::shaka::MediaInfo_AudioCodecSpecificData* codec_specific_data_;
    ::uint32_t sampling_frequency_;
    ::uint32_t time_scale_;
    ::uint32_t num_channels_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_media_5finfo_2eproto;
};// -------------------------------------------------------------------

class MediaInfo_ContentProtectionXml final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:shaka.MediaInfo.ContentProtectionXml) */ {
 public:
  inline MediaInfo_ContentProtectionXml() : MediaInfo_ContentProtectionXml(nullptr) {}
  ~MediaInfo_ContentProtectionXml() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MediaInfo_ContentProtectionXml(::google::protobuf::internal::ConstantInitialized);

  inline MediaInfo_ContentProtectionXml(const MediaInfo_ContentProtectionXml& from)
      : MediaInfo_ContentProtectionXml(nullptr, from) {}
  MediaInfo_ContentProtectionXml(MediaInfo_ContentProtectionXml&& from) noexcept
    : MediaInfo_ContentProtectionXml() {
    *this = ::std::move(from);
  }

  inline MediaInfo_ContentProtectionXml& operator=(const MediaInfo_ContentProtectionXml& from) {
    CopyFrom(from);
    return *this;
  }
  inline MediaInfo_ContentProtectionXml& operator=(MediaInfo_ContentProtectionXml&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MediaInfo_ContentProtectionXml& default_instance() {
    return *internal_default_instance();
  }
  static inline const MediaInfo_ContentProtectionXml* internal_default_instance() {
    return reinterpret_cast<const MediaInfo_ContentProtectionXml*>(
               &_MediaInfo_ContentProtectionXml_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(MediaInfo_ContentProtectionXml& a, MediaInfo_ContentProtectionXml& b) {
    a.Swap(&b);
  }
  inline void Swap(MediaInfo_ContentProtectionXml* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MediaInfo_ContentProtectionXml* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MediaInfo_ContentProtectionXml* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MediaInfo_ContentProtectionXml>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MediaInfo_ContentProtectionXml& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MediaInfo_ContentProtectionXml& from) {
    MediaInfo_ContentProtectionXml::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MediaInfo_ContentProtectionXml* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "shaka.MediaInfo.ContentProtectionXml";
  }
  protected:
  explicit MediaInfo_ContentProtectionXml(::google::protobuf::Arena* arena);
  MediaInfo_ContentProtectionXml(::google::protobuf::Arena* arena, const MediaInfo_ContentProtectionXml& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using AttributeNameValuePair = MediaInfo_ContentProtectionXml_AttributeNameValuePair;
  using Element = MediaInfo_ContentProtectionXml_Element;

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 3,
    kSubelementsFieldNumber = 4,
    kSchemeIdUriFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // repeated .shaka.MediaInfo.ContentProtectionXml.AttributeNameValuePair attributes = 3;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;

  public:
  void clear_attributes() ;
  ::shaka::MediaInfo_ContentProtectionXml_AttributeNameValuePair* mutable_attributes(int index);
  ::google::protobuf::RepeatedPtrField< ::shaka::MediaInfo_ContentProtectionXml_AttributeNameValuePair >*
      mutable_attributes();
  private:
  const ::google::protobuf::RepeatedPtrField<::shaka::MediaInfo_ContentProtectionXml_AttributeNameValuePair>& _internal_attributes() const;
  ::google::protobuf::RepeatedPtrField<::shaka::MediaInfo_ContentProtectionXml_AttributeNameValuePair>* _internal_mutable_attributes();
  public:
  const ::shaka::MediaInfo_ContentProtectionXml_AttributeNameValuePair& attributes(int index) const;
  ::shaka::MediaInfo_ContentProtectionXml_AttributeNameValuePair* add_attributes();
  const ::google::protobuf::RepeatedPtrField< ::shaka::MediaInfo_ContentProtectionXml_AttributeNameValuePair >&
      attributes() const;
  // repeated .shaka.MediaInfo.ContentProtectionXml.Element subelements = 4;
  int subelements_size() const;
  private:
  int _internal_subelements_size() const;

  public:
  void clear_subelements() ;
  ::shaka::MediaInfo_ContentProtectionXml_Element* mutable_subelements(int index);
  ::google::protobuf::RepeatedPtrField< ::shaka::MediaInfo_ContentProtectionXml_Element >*
      mutable_subelements();
  private:
  const ::google::protobuf::RepeatedPtrField<::shaka::MediaInfo_ContentProtectionXml_Element>& _internal_subelements() const;
  ::google::protobuf::RepeatedPtrField<::shaka::MediaInfo_ContentProtectionXml_Element>* _internal_mutable_subelements();
  public:
  const ::shaka::MediaInfo_ContentProtectionXml_Element& subelements(int index) const;
  ::shaka::MediaInfo_ContentProtectionXml_Element* add_subelements();
  const ::google::protobuf::RepeatedPtrField< ::shaka::MediaInfo_ContentProtectionXml_Element >&
      subelements() const;
  // optional string scheme_id_uri = 1;
  bool has_scheme_id_uri() const;
  void clear_scheme_id_uri() ;
  const std::string& scheme_id_uri() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_scheme_id_uri(Arg_&& arg, Args_... args);
  std::string* mutable_scheme_id_uri();
  PROTOBUF_NODISCARD std::string* release_scheme_id_uri();
  void set_allocated_scheme_id_uri(std::string* value);

  private:
  const std::string& _internal_scheme_id_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_scheme_id_uri(
      const std::string& value);
  std::string* _internal_mutable_scheme_id_uri();

  public:
  // optional string value = 2;
  bool has_value() const;
  void clear_value() ;
  const std::string& value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // @@protoc_insertion_point(class_scope:shaka.MediaInfo.ContentProtectionXml)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      63, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::shaka::MediaInfo_ContentProtectionXml_AttributeNameValuePair > attributes_;
    ::google::protobuf::RepeatedPtrField< ::shaka::MediaInfo_ContentProtectionXml_Element > subelements_;
    ::google::protobuf::internal::ArenaStringPtr scheme_id_uri_;
    ::google::protobuf::internal::ArenaStringPtr value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_media_5finfo_2eproto;
};// -------------------------------------------------------------------

class MediaInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:shaka.MediaInfo) */ {
 public:
  inline MediaInfo() : MediaInfo(nullptr) {}
  ~MediaInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MediaInfo(::google::protobuf::internal::ConstantInitialized);

  inline MediaInfo(const MediaInfo& from)
      : MediaInfo(nullptr, from) {}
  MediaInfo(MediaInfo&& from) noexcept
    : MediaInfo() {
    *this = ::std::move(from);
  }

  inline MediaInfo& operator=(const MediaInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MediaInfo& operator=(MediaInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MediaInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MediaInfo* internal_default_instance() {
    return reinterpret_cast<const MediaInfo*>(
               &_MediaInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(MediaInfo& a, MediaInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MediaInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MediaInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MediaInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MediaInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MediaInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MediaInfo& from) {
    MediaInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MediaInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "shaka.MediaInfo";
  }
  protected:
  explicit MediaInfo(::google::protobuf::Arena* arena);
  MediaInfo(::google::protobuf::Arena* arena, const MediaInfo& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using VideoInfo = MediaInfo_VideoInfo;
  using AudioInfo = MediaInfo_AudioInfo;
  using AudioCodecSpecificData = MediaInfo_AudioCodecSpecificData;
  using TextInfo = MediaInfo_TextInfo;
  using ProtectedContent = MediaInfo_ProtectedContent;
  using ContentProtectionXml = MediaInfo_ContentProtectionXml;

  using ContainerType = MediaInfo_ContainerType;
  static constexpr ContainerType CONTAINER_UNKNOWN = MediaInfo_ContainerType_CONTAINER_UNKNOWN;
  static constexpr ContainerType CONTAINER_MP4 = MediaInfo_ContainerType_CONTAINER_MP4;
  static constexpr ContainerType CONTAINER_MPEG2_TS = MediaInfo_ContainerType_CONTAINER_MPEG2_TS;
  static constexpr ContainerType CONTAINER_WEBM = MediaInfo_ContainerType_CONTAINER_WEBM;
  static constexpr ContainerType CONTAINER_TEXT = MediaInfo_ContainerType_CONTAINER_TEXT;
  static constexpr ContainerType CONTAINER_PACKED_AUDIO = MediaInfo_ContainerType_CONTAINER_PACKED_AUDIO;
  static inline bool ContainerType_IsValid(int value) {
    return MediaInfo_ContainerType_IsValid(value);
  }
  static constexpr ContainerType ContainerType_MIN = MediaInfo_ContainerType_ContainerType_MIN;
  static constexpr ContainerType ContainerType_MAX = MediaInfo_ContainerType_ContainerType_MAX;
  static constexpr int ContainerType_ARRAYSIZE = MediaInfo_ContainerType_ContainerType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ContainerType_descriptor() {
    return MediaInfo_ContainerType_descriptor();
  }
  template <typename T>
  static inline const std::string& ContainerType_Name(T value) {
    return MediaInfo_ContainerType_Name(value);
  }
  static inline bool ContainerType_Parse(absl::string_view name, ContainerType* value) {
    return MediaInfo_ContainerType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kContentProtectionsFieldNumber = 5,
    kHlsCharacteristicsFieldNumber = 20,
    kDashAccessibilitiesFieldNumber = 21,
    kDashRolesFieldNumber = 22,
    kSubsegmentRangesFieldNumber = 23,
    kMediaFileNameFieldNumber = 8,
    kInitSegmentNameFieldNumber = 10,
    kSegmentTemplateFieldNumber = 11,
    kMediaFileUrlFieldNumber = 17,
    kInitSegmentUrlFieldNumber = 18,
    kSegmentTemplateUrlFieldNumber = 19,
    kDashLabelFieldNumber = 29,
    kVideoInfoFieldNumber = 2,
    kAudioInfoFieldNumber = 3,
    kTextInfoFieldNumber = 4,
    kInitRangeFieldNumber = 6,
    kIndexRangeFieldNumber = 7,
    kProtectedContentFieldNumber = 15,
    kBandwidthFieldNumber = 1,
    kMediaDurationSecondsFieldNumber = 9,
    kSegmentDurationSecondsFieldNumber = 12,
    kReferenceTimeScaleFieldNumber = 13,
    kPresentationTimeOffsetFieldNumber = 16,
    kContainerTypeFieldNumber = 14,
    kForcedSubtitleFieldNumber = 26,
    kAvailabilityTimeOffsetFieldNumber = 24,
    kSegmentDurationFieldNumber = 25,
    kIndexFieldNumber = 28,
  };
  // repeated .shaka.MediaInfo.ContentProtectionXml content_protections = 5;
  int content_protections_size() const;
  private:
  int _internal_content_protections_size() const;

  public:
  void clear_content_protections() ;
  ::shaka::MediaInfo_ContentProtectionXml* mutable_content_protections(int index);
  ::google::protobuf::RepeatedPtrField< ::shaka::MediaInfo_ContentProtectionXml >*
      mutable_content_protections();
  private:
  const ::google::protobuf::RepeatedPtrField<::shaka::MediaInfo_ContentProtectionXml>& _internal_content_protections() const;
  ::google::protobuf::RepeatedPtrField<::shaka::MediaInfo_ContentProtectionXml>* _internal_mutable_content_protections();
  public:
  const ::shaka::MediaInfo_ContentProtectionXml& content_protections(int index) const;
  ::shaka::MediaInfo_ContentProtectionXml* add_content_protections();
  const ::google::protobuf::RepeatedPtrField< ::shaka::MediaInfo_ContentProtectionXml >&
      content_protections() const;
  // repeated string hls_characteristics = 20;
  int hls_characteristics_size() const;
  private:
  int _internal_hls_characteristics_size() const;

  public:
  void clear_hls_characteristics() ;
  const std::string& hls_characteristics(int index) const;
  std::string* mutable_hls_characteristics(int index);
  void set_hls_characteristics(int index, const std::string& value);
  void set_hls_characteristics(int index, std::string&& value);
  void set_hls_characteristics(int index, const char* value);
  void set_hls_characteristics(int index, const char* value, std::size_t size);
  void set_hls_characteristics(int index, absl::string_view value);
  std::string* add_hls_characteristics();
  void add_hls_characteristics(const std::string& value);
  void add_hls_characteristics(std::string&& value);
  void add_hls_characteristics(const char* value);
  void add_hls_characteristics(const char* value, std::size_t size);
  void add_hls_characteristics(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& hls_characteristics() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_hls_characteristics();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_hls_characteristics() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_hls_characteristics();

  public:
  // repeated string dash_accessibilities = 21;
  int dash_accessibilities_size() const;
  private:
  int _internal_dash_accessibilities_size() const;

  public:
  void clear_dash_accessibilities() ;
  const std::string& dash_accessibilities(int index) const;
  std::string* mutable_dash_accessibilities(int index);
  void set_dash_accessibilities(int index, const std::string& value);
  void set_dash_accessibilities(int index, std::string&& value);
  void set_dash_accessibilities(int index, const char* value);
  void set_dash_accessibilities(int index, const char* value, std::size_t size);
  void set_dash_accessibilities(int index, absl::string_view value);
  std::string* add_dash_accessibilities();
  void add_dash_accessibilities(const std::string& value);
  void add_dash_accessibilities(std::string&& value);
  void add_dash_accessibilities(const char* value);
  void add_dash_accessibilities(const char* value, std::size_t size);
  void add_dash_accessibilities(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& dash_accessibilities() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_dash_accessibilities();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_dash_accessibilities() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_dash_accessibilities();

  public:
  // repeated string dash_roles = 22;
  int dash_roles_size() const;
  private:
  int _internal_dash_roles_size() const;

  public:
  void clear_dash_roles() ;
  const std::string& dash_roles(int index) const;
  std::string* mutable_dash_roles(int index);
  void set_dash_roles(int index, const std::string& value);
  void set_dash_roles(int index, std::string&& value);
  void set_dash_roles(int index, const char* value);
  void set_dash_roles(int index, const char* value, std::size_t size);
  void set_dash_roles(int index, absl::string_view value);
  std::string* add_dash_roles();
  void add_dash_roles(const std::string& value);
  void add_dash_roles(std::string&& value);
  void add_dash_roles(const char* value);
  void add_dash_roles(const char* value, std::size_t size);
  void add_dash_roles(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& dash_roles() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_dash_roles();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_dash_roles() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_dash_roles();

  public:
  // repeated .shaka.Range subsegment_ranges = 23;
  int subsegment_ranges_size() const;
  private:
  int _internal_subsegment_ranges_size() const;

  public:
  void clear_subsegment_ranges() ;
  ::shaka::Range* mutable_subsegment_ranges(int index);
  ::google::protobuf::RepeatedPtrField< ::shaka::Range >*
      mutable_subsegment_ranges();
  private:
  const ::google::protobuf::RepeatedPtrField<::shaka::Range>& _internal_subsegment_ranges() const;
  ::google::protobuf::RepeatedPtrField<::shaka::Range>* _internal_mutable_subsegment_ranges();
  public:
  const ::shaka::Range& subsegment_ranges(int index) const;
  ::shaka::Range* add_subsegment_ranges();
  const ::google::protobuf::RepeatedPtrField< ::shaka::Range >&
      subsegment_ranges() const;
  // optional string media_file_name = 8;
  bool has_media_file_name() const;
  void clear_media_file_name() ;
  const std::string& media_file_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_media_file_name(Arg_&& arg, Args_... args);
  std::string* mutable_media_file_name();
  PROTOBUF_NODISCARD std::string* release_media_file_name();
  void set_allocated_media_file_name(std::string* value);

  private:
  const std::string& _internal_media_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_media_file_name(
      const std::string& value);
  std::string* _internal_mutable_media_file_name();

  public:
  // optional string init_segment_name = 10;
  bool has_init_segment_name() const;
  void clear_init_segment_name() ;
  const std::string& init_segment_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_init_segment_name(Arg_&& arg, Args_... args);
  std::string* mutable_init_segment_name();
  PROTOBUF_NODISCARD std::string* release_init_segment_name();
  void set_allocated_init_segment_name(std::string* value);

  private:
  const std::string& _internal_init_segment_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_init_segment_name(
      const std::string& value);
  std::string* _internal_mutable_init_segment_name();

  public:
  // optional string segment_template = 11;
  bool has_segment_template() const;
  void clear_segment_template() ;
  const std::string& segment_template() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_segment_template(Arg_&& arg, Args_... args);
  std::string* mutable_segment_template();
  PROTOBUF_NODISCARD std::string* release_segment_template();
  void set_allocated_segment_template(std::string* value);

  private:
  const std::string& _internal_segment_template() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_segment_template(
      const std::string& value);
  std::string* _internal_mutable_segment_template();

  public:
  // optional string media_file_url = 17;
  bool has_media_file_url() const;
  void clear_media_file_url() ;
  const std::string& media_file_url() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_media_file_url(Arg_&& arg, Args_... args);
  std::string* mutable_media_file_url();
  PROTOBUF_NODISCARD std::string* release_media_file_url();
  void set_allocated_media_file_url(std::string* value);

  private:
  const std::string& _internal_media_file_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_media_file_url(
      const std::string& value);
  std::string* _internal_mutable_media_file_url();

  public:
  // optional string init_segment_url = 18;
  bool has_init_segment_url() const;
  void clear_init_segment_url() ;
  const std::string& init_segment_url() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_init_segment_url(Arg_&& arg, Args_... args);
  std::string* mutable_init_segment_url();
  PROTOBUF_NODISCARD std::string* release_init_segment_url();
  void set_allocated_init_segment_url(std::string* value);

  private:
  const std::string& _internal_init_segment_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_init_segment_url(
      const std::string& value);
  std::string* _internal_mutable_init_segment_url();

  public:
  // optional string segment_template_url = 19;
  bool has_segment_template_url() const;
  void clear_segment_template_url() ;
  const std::string& segment_template_url() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_segment_template_url(Arg_&& arg, Args_... args);
  std::string* mutable_segment_template_url();
  PROTOBUF_NODISCARD std::string* release_segment_template_url();
  void set_allocated_segment_template_url(std::string* value);

  private:
  const std::string& _internal_segment_template_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_segment_template_url(
      const std::string& value);
  std::string* _internal_mutable_segment_template_url();

  public:
  // optional string dash_label = 29;
  bool has_dash_label() const;
  void clear_dash_label() ;
  const std::string& dash_label() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dash_label(Arg_&& arg, Args_... args);
  std::string* mutable_dash_label();
  PROTOBUF_NODISCARD std::string* release_dash_label();
  void set_allocated_dash_label(std::string* value);

  private:
  const std::string& _internal_dash_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dash_label(
      const std::string& value);
  std::string* _internal_mutable_dash_label();

  public:
  // optional .shaka.MediaInfo.VideoInfo video_info = 2;
  bool has_video_info() const;
  void clear_video_info() ;
  const ::shaka::MediaInfo_VideoInfo& video_info() const;
  PROTOBUF_NODISCARD ::shaka::MediaInfo_VideoInfo* release_video_info();
  ::shaka::MediaInfo_VideoInfo* mutable_video_info();
  void set_allocated_video_info(::shaka::MediaInfo_VideoInfo* value);
  void unsafe_arena_set_allocated_video_info(::shaka::MediaInfo_VideoInfo* value);
  ::shaka::MediaInfo_VideoInfo* unsafe_arena_release_video_info();

  private:
  const ::shaka::MediaInfo_VideoInfo& _internal_video_info() const;
  ::shaka::MediaInfo_VideoInfo* _internal_mutable_video_info();

  public:
  // optional .shaka.MediaInfo.AudioInfo audio_info = 3;
  bool has_audio_info() const;
  void clear_audio_info() ;
  const ::shaka::MediaInfo_AudioInfo& audio_info() const;
  PROTOBUF_NODISCARD ::shaka::MediaInfo_AudioInfo* release_audio_info();
  ::shaka::MediaInfo_AudioInfo* mutable_audio_info();
  void set_allocated_audio_info(::shaka::MediaInfo_AudioInfo* value);
  void unsafe_arena_set_allocated_audio_info(::shaka::MediaInfo_AudioInfo* value);
  ::shaka::MediaInfo_AudioInfo* unsafe_arena_release_audio_info();

  private:
  const ::shaka::MediaInfo_AudioInfo& _internal_audio_info() const;
  ::shaka::MediaInfo_AudioInfo* _internal_mutable_audio_info();

  public:
  // optional .shaka.MediaInfo.TextInfo text_info = 4;
  bool has_text_info() const;
  void clear_text_info() ;
  const ::shaka::MediaInfo_TextInfo& text_info() const;
  PROTOBUF_NODISCARD ::shaka::MediaInfo_TextInfo* release_text_info();
  ::shaka::MediaInfo_TextInfo* mutable_text_info();
  void set_allocated_text_info(::shaka::MediaInfo_TextInfo* value);
  void unsafe_arena_set_allocated_text_info(::shaka::MediaInfo_TextInfo* value);
  ::shaka::MediaInfo_TextInfo* unsafe_arena_release_text_info();

  private:
  const ::shaka::MediaInfo_TextInfo& _internal_text_info() const;
  ::shaka::MediaInfo_TextInfo* _internal_mutable_text_info();

  public:
  // optional .shaka.Range init_range = 6;
  bool has_init_range() const;
  void clear_init_range() ;
  const ::shaka::Range& init_range() const;
  PROTOBUF_NODISCARD ::shaka::Range* release_init_range();
  ::shaka::Range* mutable_init_range();
  void set_allocated_init_range(::shaka::Range* value);
  void unsafe_arena_set_allocated_init_range(::shaka::Range* value);
  ::shaka::Range* unsafe_arena_release_init_range();

  private:
  const ::shaka::Range& _internal_init_range() const;
  ::shaka::Range* _internal_mutable_init_range();

  public:
  // optional .shaka.Range index_range = 7;
  bool has_index_range() const;
  void clear_index_range() ;
  const ::shaka::Range& index_range() const;
  PROTOBUF_NODISCARD ::shaka::Range* release_index_range();
  ::shaka::Range* mutable_index_range();
  void set_allocated_index_range(::shaka::Range* value);
  void unsafe_arena_set_allocated_index_range(::shaka::Range* value);
  ::shaka::Range* unsafe_arena_release_index_range();

  private:
  const ::shaka::Range& _internal_index_range() const;
  ::shaka::Range* _internal_mutable_index_range();

  public:
  // optional .shaka.MediaInfo.ProtectedContent protected_content = 15;
  bool has_protected_content() const;
  void clear_protected_content() ;
  const ::shaka::MediaInfo_ProtectedContent& protected_content() const;
  PROTOBUF_NODISCARD ::shaka::MediaInfo_ProtectedContent* release_protected_content();
  ::shaka::MediaInfo_ProtectedContent* mutable_protected_content();
  void set_allocated_protected_content(::shaka::MediaInfo_ProtectedContent* value);
  void unsafe_arena_set_allocated_protected_content(::shaka::MediaInfo_ProtectedContent* value);
  ::shaka::MediaInfo_ProtectedContent* unsafe_arena_release_protected_content();

  private:
  const ::shaka::MediaInfo_ProtectedContent& _internal_protected_content() const;
  ::shaka::MediaInfo_ProtectedContent* _internal_mutable_protected_content();

  public:
  // optional uint32 bandwidth = 1;
  bool has_bandwidth() const;
  void clear_bandwidth() ;
  ::uint32_t bandwidth() const;
  void set_bandwidth(::uint32_t value);

  private:
  ::uint32_t _internal_bandwidth() const;
  void _internal_set_bandwidth(::uint32_t value);

  public:
  // optional float media_duration_seconds = 9;
  bool has_media_duration_seconds() const;
  void clear_media_duration_seconds() ;
  float media_duration_seconds() const;
  void set_media_duration_seconds(float value);

  private:
  float _internal_media_duration_seconds() const;
  void _internal_set_media_duration_seconds(float value);

  public:
  // optional float segment_duration_seconds = 12 [deprecated = true];
  [[deprecated]]  bool has_segment_duration_seconds() const;
  [[deprecated]]  void clear_segment_duration_seconds() ;
  [[deprecated]] float segment_duration_seconds() const;
  [[deprecated]] void set_segment_duration_seconds(float value);

  private:
  float _internal_segment_duration_seconds() const;
  void _internal_set_segment_duration_seconds(float value);

  public:
  // optional uint32 reference_time_scale = 13;
  bool has_reference_time_scale() const;
  void clear_reference_time_scale() ;
  ::uint32_t reference_time_scale() const;
  void set_reference_time_scale(::uint32_t value);

  private:
  ::uint32_t _internal_reference_time_scale() const;
  void _internal_set_reference_time_scale(::uint32_t value);

  public:
  // optional uint64 presentation_time_offset = 16;
  bool has_presentation_time_offset() const;
  void clear_presentation_time_offset() ;
  ::uint64_t presentation_time_offset() const;
  void set_presentation_time_offset(::uint64_t value);

  private:
  ::uint64_t _internal_presentation_time_offset() const;
  void _internal_set_presentation_time_offset(::uint64_t value);

  public:
  // optional .shaka.MediaInfo.ContainerType container_type = 14 [default = CONTAINER_UNKNOWN];
  bool has_container_type() const;
  void clear_container_type() ;
  ::shaka::MediaInfo_ContainerType container_type() const;
  void set_container_type(::shaka::MediaInfo_ContainerType value);

  private:
  ::shaka::MediaInfo_ContainerType _internal_container_type() const;
  void _internal_set_container_type(::shaka::MediaInfo_ContainerType value);

  public:
  // optional bool forced_subtitle = 26 [default = false];
  bool has_forced_subtitle() const;
  void clear_forced_subtitle() ;
  bool forced_subtitle() const;
  void set_forced_subtitle(bool value);

  private:
  bool _internal_forced_subtitle() const;
  void _internal_set_forced_subtitle(bool value);

  public:
  // optional double availability_time_offset = 24;
  bool has_availability_time_offset() const;
  void clear_availability_time_offset() ;
  double availability_time_offset() const;
  void set_availability_time_offset(double value);

  private:
  double _internal_availability_time_offset() const;
  void _internal_set_availability_time_offset(double value);

  public:
  // optional uint64 segment_duration = 25;
  bool has_segment_duration() const;
  void clear_segment_duration() ;
  ::uint64_t segment_duration() const;
  void set_segment_duration(::uint64_t value);

  private:
  ::uint64_t _internal_segment_duration() const;
  void _internal_set_segment_duration(::uint64_t value);

  public:
  // optional uint32 index = 28;
  bool has_index() const;
  void clear_index() ;
  ::uint32_t index() const;
  void set_index(::uint32_t value);

  private:
  ::uint32_t _internal_index() const;
  void _internal_set_index(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:shaka.MediaInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 28, 9,
      205, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::shaka::MediaInfo_ContentProtectionXml > content_protections_;
    ::google::protobuf::RepeatedPtrField<std::string> hls_characteristics_;
    ::google::protobuf::RepeatedPtrField<std::string> dash_accessibilities_;
    ::google::protobuf::RepeatedPtrField<std::string> dash_roles_;
    ::google::protobuf::RepeatedPtrField< ::shaka::Range > subsegment_ranges_;
    ::google::protobuf::internal::ArenaStringPtr media_file_name_;
    ::google::protobuf::internal::ArenaStringPtr init_segment_name_;
    ::google::protobuf::internal::ArenaStringPtr segment_template_;
    ::google::protobuf::internal::ArenaStringPtr media_file_url_;
    ::google::protobuf::internal::ArenaStringPtr init_segment_url_;
    ::google::protobuf::internal::ArenaStringPtr segment_template_url_;
    ::google::protobuf::internal::ArenaStringPtr dash_label_;
    ::shaka::MediaInfo_VideoInfo* video_info_;
    ::shaka::MediaInfo_AudioInfo* audio_info_;
    ::shaka::MediaInfo_TextInfo* text_info_;
    ::shaka::Range* init_range_;
    ::shaka::Range* index_range_;
    ::shaka::MediaInfo_ProtectedContent* protected_content_;
    ::uint32_t bandwidth_;
    float media_duration_seconds_;
    float segment_duration_seconds_;
    ::uint32_t reference_time_scale_;
    ::uint64_t presentation_time_offset_;
    int container_type_;
    bool forced_subtitle_;
    double availability_time_offset_;
    ::uint64_t segment_duration_;
    ::uint32_t index_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_media_5finfo_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Range

// optional uint64 begin = 1;
inline bool Range::has_begin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Range::clear_begin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.begin_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t Range::begin() const {
  // @@protoc_insertion_point(field_get:shaka.Range.begin)
  return _internal_begin();
}
inline void Range::set_begin(::uint64_t value) {
  _internal_set_begin(value);
  // @@protoc_insertion_point(field_set:shaka.Range.begin)
}
inline ::uint64_t Range::_internal_begin() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.begin_;
}
inline void Range::_internal_set_begin(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.begin_ = value;
}

// optional uint64 end = 2;
inline bool Range::has_end() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Range::clear_end() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.end_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t Range::end() const {
  // @@protoc_insertion_point(field_get:shaka.Range.end)
  return _internal_end();
}
inline void Range::set_end(::uint64_t value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:shaka.Range.end)
}
inline ::uint64_t Range::_internal_end() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.end_;
}
inline void Range::_internal_set_end(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.end_ = value;
}

// -------------------------------------------------------------------

// MediaInfo_VideoInfo

// optional string codec = 1;
inline bool MediaInfo_VideoInfo::has_codec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MediaInfo_VideoInfo::clear_codec() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.codec_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MediaInfo_VideoInfo::codec() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.VideoInfo.codec)
  return _internal_codec();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MediaInfo_VideoInfo::set_codec(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.codec_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.VideoInfo.codec)
}
inline std::string* MediaInfo_VideoInfo::mutable_codec() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_codec();
  // @@protoc_insertion_point(field_mutable:shaka.MediaInfo.VideoInfo.codec)
  return _s;
}
inline const std::string& MediaInfo_VideoInfo::_internal_codec() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.codec_.Get();
}
inline void MediaInfo_VideoInfo::_internal_set_codec(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.codec_.Set(value, GetArena());
}
inline std::string* MediaInfo_VideoInfo::_internal_mutable_codec() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.codec_.Mutable( GetArena());
}
inline std::string* MediaInfo_VideoInfo::release_codec() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.MediaInfo.VideoInfo.codec)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.codec_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.codec_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MediaInfo_VideoInfo::set_allocated_codec(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.codec_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.codec_.IsDefault()) {
          _impl_.codec_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:shaka.MediaInfo.VideoInfo.codec)
}

// optional uint32 width = 2;
inline bool MediaInfo_VideoInfo::has_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void MediaInfo_VideoInfo::clear_width() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.width_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t MediaInfo_VideoInfo::width() const {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.VideoInfo.width)
  return _internal_width();
}
inline void MediaInfo_VideoInfo::set_width(::uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.VideoInfo.width)
}
inline ::uint32_t MediaInfo_VideoInfo::_internal_width() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.width_;
}
inline void MediaInfo_VideoInfo::_internal_set_width(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.width_ = value;
}

// optional uint32 height = 3;
inline bool MediaInfo_VideoInfo::has_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void MediaInfo_VideoInfo::clear_height() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.height_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t MediaInfo_VideoInfo::height() const {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.VideoInfo.height)
  return _internal_height();
}
inline void MediaInfo_VideoInfo::set_height(::uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.VideoInfo.height)
}
inline ::uint32_t MediaInfo_VideoInfo::_internal_height() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.height_;
}
inline void MediaInfo_VideoInfo::_internal_set_height(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.height_ = value;
}

// optional uint32 time_scale = 4;
inline bool MediaInfo_VideoInfo::has_time_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void MediaInfo_VideoInfo::clear_time_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.time_scale_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint32_t MediaInfo_VideoInfo::time_scale() const {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.VideoInfo.time_scale)
  return _internal_time_scale();
}
inline void MediaInfo_VideoInfo::set_time_scale(::uint32_t value) {
  _internal_set_time_scale(value);
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.VideoInfo.time_scale)
}
inline ::uint32_t MediaInfo_VideoInfo::_internal_time_scale() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.time_scale_;
}
inline void MediaInfo_VideoInfo::_internal_set_time_scale(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.time_scale_ = value;
}

// optional uint64 frame_duration = 5;
inline bool MediaInfo_VideoInfo::has_frame_duration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void MediaInfo_VideoInfo::clear_frame_duration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.frame_duration_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint64_t MediaInfo_VideoInfo::frame_duration() const {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.VideoInfo.frame_duration)
  return _internal_frame_duration();
}
inline void MediaInfo_VideoInfo::set_frame_duration(::uint64_t value) {
  _internal_set_frame_duration(value);
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.VideoInfo.frame_duration)
}
inline ::uint64_t MediaInfo_VideoInfo::_internal_frame_duration() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.frame_duration_;
}
inline void MediaInfo_VideoInfo::_internal_set_frame_duration(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.frame_duration_ = value;
}

// optional bytes decoder_config = 6;
inline bool MediaInfo_VideoInfo::has_decoder_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MediaInfo_VideoInfo::clear_decoder_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.decoder_config_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MediaInfo_VideoInfo::decoder_config() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.VideoInfo.decoder_config)
  return _internal_decoder_config();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MediaInfo_VideoInfo::set_decoder_config(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.decoder_config_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.VideoInfo.decoder_config)
}
inline std::string* MediaInfo_VideoInfo::mutable_decoder_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_decoder_config();
  // @@protoc_insertion_point(field_mutable:shaka.MediaInfo.VideoInfo.decoder_config)
  return _s;
}
inline const std::string& MediaInfo_VideoInfo::_internal_decoder_config() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.decoder_config_.Get();
}
inline void MediaInfo_VideoInfo::_internal_set_decoder_config(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.decoder_config_.Set(value, GetArena());
}
inline std::string* MediaInfo_VideoInfo::_internal_mutable_decoder_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.decoder_config_.Mutable( GetArena());
}
inline std::string* MediaInfo_VideoInfo::release_decoder_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.MediaInfo.VideoInfo.decoder_config)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.decoder_config_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.decoder_config_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MediaInfo_VideoInfo::set_allocated_decoder_config(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.decoder_config_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.decoder_config_.IsDefault()) {
          _impl_.decoder_config_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:shaka.MediaInfo.VideoInfo.decoder_config)
}

// optional uint32 pixel_width = 7;
inline bool MediaInfo_VideoInfo::has_pixel_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void MediaInfo_VideoInfo::clear_pixel_width() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pixel_width_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::uint32_t MediaInfo_VideoInfo::pixel_width() const {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.VideoInfo.pixel_width)
  return _internal_pixel_width();
}
inline void MediaInfo_VideoInfo::set_pixel_width(::uint32_t value) {
  _internal_set_pixel_width(value);
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.VideoInfo.pixel_width)
}
inline ::uint32_t MediaInfo_VideoInfo::_internal_pixel_width() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pixel_width_;
}
inline void MediaInfo_VideoInfo::_internal_set_pixel_width(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.pixel_width_ = value;
}

// optional uint32 pixel_height = 8;
inline bool MediaInfo_VideoInfo::has_pixel_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void MediaInfo_VideoInfo::clear_pixel_height() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pixel_height_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::uint32_t MediaInfo_VideoInfo::pixel_height() const {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.VideoInfo.pixel_height)
  return _internal_pixel_height();
}
inline void MediaInfo_VideoInfo::set_pixel_height(::uint32_t value) {
  _internal_set_pixel_height(value);
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.VideoInfo.pixel_height)
}
inline ::uint32_t MediaInfo_VideoInfo::_internal_pixel_height() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pixel_height_;
}
inline void MediaInfo_VideoInfo::_internal_set_pixel_height(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.pixel_height_ = value;
}

// optional uint32 playback_rate = 9;
inline bool MediaInfo_VideoInfo::has_playback_rate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void MediaInfo_VideoInfo::clear_playback_rate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.playback_rate_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::uint32_t MediaInfo_VideoInfo::playback_rate() const {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.VideoInfo.playback_rate)
  return _internal_playback_rate();
}
inline void MediaInfo_VideoInfo::set_playback_rate(::uint32_t value) {
  _internal_set_playback_rate(value);
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.VideoInfo.playback_rate)
}
inline ::uint32_t MediaInfo_VideoInfo::_internal_playback_rate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.playback_rate_;
}
inline void MediaInfo_VideoInfo::_internal_set_playback_rate(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.playback_rate_ = value;
}

// optional uint32 transfer_characteristics = 10;
inline bool MediaInfo_VideoInfo::has_transfer_characteristics() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void MediaInfo_VideoInfo::clear_transfer_characteristics() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.transfer_characteristics_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::uint32_t MediaInfo_VideoInfo::transfer_characteristics() const {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.VideoInfo.transfer_characteristics)
  return _internal_transfer_characteristics();
}
inline void MediaInfo_VideoInfo::set_transfer_characteristics(::uint32_t value) {
  _internal_set_transfer_characteristics(value);
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.VideoInfo.transfer_characteristics)
}
inline ::uint32_t MediaInfo_VideoInfo::_internal_transfer_characteristics() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transfer_characteristics_;
}
inline void MediaInfo_VideoInfo::_internal_set_transfer_characteristics(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.transfer_characteristics_ = value;
}

// optional uint32 color_primaries = 11;
inline bool MediaInfo_VideoInfo::has_color_primaries() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void MediaInfo_VideoInfo::clear_color_primaries() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.color_primaries_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::uint32_t MediaInfo_VideoInfo::color_primaries() const {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.VideoInfo.color_primaries)
  return _internal_color_primaries();
}
inline void MediaInfo_VideoInfo::set_color_primaries(::uint32_t value) {
  _internal_set_color_primaries(value);
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.VideoInfo.color_primaries)
}
inline ::uint32_t MediaInfo_VideoInfo::_internal_color_primaries() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.color_primaries_;
}
inline void MediaInfo_VideoInfo::_internal_set_color_primaries(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.color_primaries_ = value;
}

// optional uint32 matrix_coefficients = 12;
inline bool MediaInfo_VideoInfo::has_matrix_coefficients() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void MediaInfo_VideoInfo::clear_matrix_coefficients() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.matrix_coefficients_ = 0u;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::uint32_t MediaInfo_VideoInfo::matrix_coefficients() const {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.VideoInfo.matrix_coefficients)
  return _internal_matrix_coefficients();
}
inline void MediaInfo_VideoInfo::set_matrix_coefficients(::uint32_t value) {
  _internal_set_matrix_coefficients(value);
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.VideoInfo.matrix_coefficients)
}
inline ::uint32_t MediaInfo_VideoInfo::_internal_matrix_coefficients() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.matrix_coefficients_;
}
inline void MediaInfo_VideoInfo::_internal_set_matrix_coefficients(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.matrix_coefficients_ = value;
}

// optional string supplemental_codec = 13;
inline bool MediaInfo_VideoInfo::has_supplemental_codec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MediaInfo_VideoInfo::clear_supplemental_codec() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.supplemental_codec_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MediaInfo_VideoInfo::supplemental_codec() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.VideoInfo.supplemental_codec)
  return _internal_supplemental_codec();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MediaInfo_VideoInfo::set_supplemental_codec(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.supplemental_codec_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.VideoInfo.supplemental_codec)
}
inline std::string* MediaInfo_VideoInfo::mutable_supplemental_codec() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_supplemental_codec();
  // @@protoc_insertion_point(field_mutable:shaka.MediaInfo.VideoInfo.supplemental_codec)
  return _s;
}
inline const std::string& MediaInfo_VideoInfo::_internal_supplemental_codec() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.supplemental_codec_.Get();
}
inline void MediaInfo_VideoInfo::_internal_set_supplemental_codec(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.supplemental_codec_.Set(value, GetArena());
}
inline std::string* MediaInfo_VideoInfo::_internal_mutable_supplemental_codec() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.supplemental_codec_.Mutable( GetArena());
}
inline std::string* MediaInfo_VideoInfo::release_supplemental_codec() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.MediaInfo.VideoInfo.supplemental_codec)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.supplemental_codec_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.supplemental_codec_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MediaInfo_VideoInfo::set_allocated_supplemental_codec(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.supplemental_codec_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.supplemental_codec_.IsDefault()) {
          _impl_.supplemental_codec_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:shaka.MediaInfo.VideoInfo.supplemental_codec)
}

// optional uint32 compatible_brand = 14;
inline bool MediaInfo_VideoInfo::has_compatible_brand() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void MediaInfo_VideoInfo::clear_compatible_brand() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.compatible_brand_ = 0u;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline ::uint32_t MediaInfo_VideoInfo::compatible_brand() const {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.VideoInfo.compatible_brand)
  return _internal_compatible_brand();
}
inline void MediaInfo_VideoInfo::set_compatible_brand(::uint32_t value) {
  _internal_set_compatible_brand(value);
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.VideoInfo.compatible_brand)
}
inline ::uint32_t MediaInfo_VideoInfo::_internal_compatible_brand() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.compatible_brand_;
}
inline void MediaInfo_VideoInfo::_internal_set_compatible_brand(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.compatible_brand_ = value;
}

// -------------------------------------------------------------------

// MediaInfo_AudioInfo

// optional string codec = 1;
inline bool MediaInfo_AudioInfo::has_codec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MediaInfo_AudioInfo::clear_codec() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.codec_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MediaInfo_AudioInfo::codec() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.AudioInfo.codec)
  return _internal_codec();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MediaInfo_AudioInfo::set_codec(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.codec_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.AudioInfo.codec)
}
inline std::string* MediaInfo_AudioInfo::mutable_codec() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_codec();
  // @@protoc_insertion_point(field_mutable:shaka.MediaInfo.AudioInfo.codec)
  return _s;
}
inline const std::string& MediaInfo_AudioInfo::_internal_codec() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.codec_.Get();
}
inline void MediaInfo_AudioInfo::_internal_set_codec(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.codec_.Set(value, GetArena());
}
inline std::string* MediaInfo_AudioInfo::_internal_mutable_codec() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.codec_.Mutable( GetArena());
}
inline std::string* MediaInfo_AudioInfo::release_codec() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.MediaInfo.AudioInfo.codec)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.codec_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.codec_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MediaInfo_AudioInfo::set_allocated_codec(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.codec_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.codec_.IsDefault()) {
          _impl_.codec_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:shaka.MediaInfo.AudioInfo.codec)
}

// optional uint32 sampling_frequency = 2;
inline bool MediaInfo_AudioInfo::has_sampling_frequency() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void MediaInfo_AudioInfo::clear_sampling_frequency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sampling_frequency_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t MediaInfo_AudioInfo::sampling_frequency() const {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.AudioInfo.sampling_frequency)
  return _internal_sampling_frequency();
}
inline void MediaInfo_AudioInfo::set_sampling_frequency(::uint32_t value) {
  _internal_set_sampling_frequency(value);
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.AudioInfo.sampling_frequency)
}
inline ::uint32_t MediaInfo_AudioInfo::_internal_sampling_frequency() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sampling_frequency_;
}
inline void MediaInfo_AudioInfo::_internal_set_sampling_frequency(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.sampling_frequency_ = value;
}

// optional uint32 time_scale = 3;
inline bool MediaInfo_AudioInfo::has_time_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void MediaInfo_AudioInfo::clear_time_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.time_scale_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint32_t MediaInfo_AudioInfo::time_scale() const {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.AudioInfo.time_scale)
  return _internal_time_scale();
}
inline void MediaInfo_AudioInfo::set_time_scale(::uint32_t value) {
  _internal_set_time_scale(value);
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.AudioInfo.time_scale)
}
inline ::uint32_t MediaInfo_AudioInfo::_internal_time_scale() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.time_scale_;
}
inline void MediaInfo_AudioInfo::_internal_set_time_scale(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.time_scale_ = value;
}

// optional uint32 num_channels = 4;
inline bool MediaInfo_AudioInfo::has_num_channels() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void MediaInfo_AudioInfo::clear_num_channels() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_channels_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint32_t MediaInfo_AudioInfo::num_channels() const {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.AudioInfo.num_channels)
  return _internal_num_channels();
}
inline void MediaInfo_AudioInfo::set_num_channels(::uint32_t value) {
  _internal_set_num_channels(value);
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.AudioInfo.num_channels)
}
inline ::uint32_t MediaInfo_AudioInfo::_internal_num_channels() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_channels_;
}
inline void MediaInfo_AudioInfo::_internal_set_num_channels(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.num_channels_ = value;
}

// optional string language = 5;
inline bool MediaInfo_AudioInfo::has_language() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MediaInfo_AudioInfo::clear_language() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.language_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MediaInfo_AudioInfo::language() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.AudioInfo.language)
  return _internal_language();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MediaInfo_AudioInfo::set_language(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.language_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.AudioInfo.language)
}
inline std::string* MediaInfo_AudioInfo::mutable_language() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:shaka.MediaInfo.AudioInfo.language)
  return _s;
}
inline const std::string& MediaInfo_AudioInfo::_internal_language() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.language_.Get();
}
inline void MediaInfo_AudioInfo::_internal_set_language(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.language_.Set(value, GetArena());
}
inline std::string* MediaInfo_AudioInfo::_internal_mutable_language() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.language_.Mutable( GetArena());
}
inline std::string* MediaInfo_AudioInfo::release_language() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.MediaInfo.AudioInfo.language)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.language_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.language_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MediaInfo_AudioInfo::set_allocated_language(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.language_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.language_.IsDefault()) {
          _impl_.language_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:shaka.MediaInfo.AudioInfo.language)
}

// optional bytes decoder_config = 6;
inline bool MediaInfo_AudioInfo::has_decoder_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MediaInfo_AudioInfo::clear_decoder_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.decoder_config_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MediaInfo_AudioInfo::decoder_config() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.AudioInfo.decoder_config)
  return _internal_decoder_config();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MediaInfo_AudioInfo::set_decoder_config(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.decoder_config_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.AudioInfo.decoder_config)
}
inline std::string* MediaInfo_AudioInfo::mutable_decoder_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_decoder_config();
  // @@protoc_insertion_point(field_mutable:shaka.MediaInfo.AudioInfo.decoder_config)
  return _s;
}
inline const std::string& MediaInfo_AudioInfo::_internal_decoder_config() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.decoder_config_.Get();
}
inline void MediaInfo_AudioInfo::_internal_set_decoder_config(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.decoder_config_.Set(value, GetArena());
}
inline std::string* MediaInfo_AudioInfo::_internal_mutable_decoder_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.decoder_config_.Mutable( GetArena());
}
inline std::string* MediaInfo_AudioInfo::release_decoder_config() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.MediaInfo.AudioInfo.decoder_config)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.decoder_config_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.decoder_config_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MediaInfo_AudioInfo::set_allocated_decoder_config(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.decoder_config_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.decoder_config_.IsDefault()) {
          _impl_.decoder_config_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:shaka.MediaInfo.AudioInfo.decoder_config)
}

// optional .shaka.MediaInfo.AudioCodecSpecificData codec_specific_data = 7;
inline bool MediaInfo_AudioInfo::has_codec_specific_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.codec_specific_data_ != nullptr);
  return value;
}
inline void MediaInfo_AudioInfo::clear_codec_specific_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.codec_specific_data_ != nullptr) _impl_.codec_specific_data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::shaka::MediaInfo_AudioCodecSpecificData& MediaInfo_AudioInfo::_internal_codec_specific_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::shaka::MediaInfo_AudioCodecSpecificData* p = _impl_.codec_specific_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::shaka::MediaInfo_AudioCodecSpecificData&>(::shaka::_MediaInfo_AudioCodecSpecificData_default_instance_);
}
inline const ::shaka::MediaInfo_AudioCodecSpecificData& MediaInfo_AudioInfo::codec_specific_data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.AudioInfo.codec_specific_data)
  return _internal_codec_specific_data();
}
inline void MediaInfo_AudioInfo::unsafe_arena_set_allocated_codec_specific_data(::shaka::MediaInfo_AudioCodecSpecificData* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.codec_specific_data_);
  }
  _impl_.codec_specific_data_ = reinterpret_cast<::shaka::MediaInfo_AudioCodecSpecificData*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:shaka.MediaInfo.AudioInfo.codec_specific_data)
}
inline ::shaka::MediaInfo_AudioCodecSpecificData* MediaInfo_AudioInfo::release_codec_specific_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::shaka::MediaInfo_AudioCodecSpecificData* released = _impl_.codec_specific_data_;
  _impl_.codec_specific_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::shaka::MediaInfo_AudioCodecSpecificData* MediaInfo_AudioInfo::unsafe_arena_release_codec_specific_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.MediaInfo.AudioInfo.codec_specific_data)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::shaka::MediaInfo_AudioCodecSpecificData* temp = _impl_.codec_specific_data_;
  _impl_.codec_specific_data_ = nullptr;
  return temp;
}
inline ::shaka::MediaInfo_AudioCodecSpecificData* MediaInfo_AudioInfo::_internal_mutable_codec_specific_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.codec_specific_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::shaka::MediaInfo_AudioCodecSpecificData>(GetArena());
    _impl_.codec_specific_data_ = reinterpret_cast<::shaka::MediaInfo_AudioCodecSpecificData*>(p);
  }
  return _impl_.codec_specific_data_;
}
inline ::shaka::MediaInfo_AudioCodecSpecificData* MediaInfo_AudioInfo::mutable_codec_specific_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::shaka::MediaInfo_AudioCodecSpecificData* _msg = _internal_mutable_codec_specific_data();
  // @@protoc_insertion_point(field_mutable:shaka.MediaInfo.AudioInfo.codec_specific_data)
  return _msg;
}
inline void MediaInfo_AudioInfo::set_allocated_codec_specific_data(::shaka::MediaInfo_AudioCodecSpecificData* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::shaka::MediaInfo_AudioCodecSpecificData*>(_impl_.codec_specific_data_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::shaka::MediaInfo_AudioCodecSpecificData*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.codec_specific_data_ = reinterpret_cast<::shaka::MediaInfo_AudioCodecSpecificData*>(value);
  // @@protoc_insertion_point(field_set_allocated:shaka.MediaInfo.AudioInfo.codec_specific_data)
}

// -------------------------------------------------------------------

// MediaInfo_AudioCodecSpecificData

// optional uint32 channel_mask = 1;
inline bool MediaInfo_AudioCodecSpecificData::has_channel_mask() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MediaInfo_AudioCodecSpecificData::clear_channel_mask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channel_mask_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t MediaInfo_AudioCodecSpecificData::channel_mask() const {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.AudioCodecSpecificData.channel_mask)
  return _internal_channel_mask();
}
inline void MediaInfo_AudioCodecSpecificData::set_channel_mask(::uint32_t value) {
  _internal_set_channel_mask(value);
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.AudioCodecSpecificData.channel_mask)
}
inline ::uint32_t MediaInfo_AudioCodecSpecificData::_internal_channel_mask() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.channel_mask_;
}
inline void MediaInfo_AudioCodecSpecificData::_internal_set_channel_mask(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.channel_mask_ = value;
}

// optional uint32 channel_mpeg_value = 2;
inline bool MediaInfo_AudioCodecSpecificData::has_channel_mpeg_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MediaInfo_AudioCodecSpecificData::clear_channel_mpeg_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channel_mpeg_value_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t MediaInfo_AudioCodecSpecificData::channel_mpeg_value() const {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.AudioCodecSpecificData.channel_mpeg_value)
  return _internal_channel_mpeg_value();
}
inline void MediaInfo_AudioCodecSpecificData::set_channel_mpeg_value(::uint32_t value) {
  _internal_set_channel_mpeg_value(value);
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.AudioCodecSpecificData.channel_mpeg_value)
}
inline ::uint32_t MediaInfo_AudioCodecSpecificData::_internal_channel_mpeg_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.channel_mpeg_value_;
}
inline void MediaInfo_AudioCodecSpecificData::_internal_set_channel_mpeg_value(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.channel_mpeg_value_ = value;
}

// optional uint32 ec3_joc_complexity = 3;
inline bool MediaInfo_AudioCodecSpecificData::has_ec3_joc_complexity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MediaInfo_AudioCodecSpecificData::clear_ec3_joc_complexity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ec3_joc_complexity_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t MediaInfo_AudioCodecSpecificData::ec3_joc_complexity() const {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.AudioCodecSpecificData.ec3_joc_complexity)
  return _internal_ec3_joc_complexity();
}
inline void MediaInfo_AudioCodecSpecificData::set_ec3_joc_complexity(::uint32_t value) {
  _internal_set_ec3_joc_complexity(value);
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.AudioCodecSpecificData.ec3_joc_complexity)
}
inline ::uint32_t MediaInfo_AudioCodecSpecificData::_internal_ec3_joc_complexity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ec3_joc_complexity_;
}
inline void MediaInfo_AudioCodecSpecificData::_internal_set_ec3_joc_complexity(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.ec3_joc_complexity_ = value;
}

// optional bool ac4_ims_flag = 4;
inline bool MediaInfo_AudioCodecSpecificData::has_ac4_ims_flag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void MediaInfo_AudioCodecSpecificData::clear_ac4_ims_flag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ac4_ims_flag_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool MediaInfo_AudioCodecSpecificData::ac4_ims_flag() const {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.AudioCodecSpecificData.ac4_ims_flag)
  return _internal_ac4_ims_flag();
}
inline void MediaInfo_AudioCodecSpecificData::set_ac4_ims_flag(bool value) {
  _internal_set_ac4_ims_flag(value);
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.AudioCodecSpecificData.ac4_ims_flag)
}
inline bool MediaInfo_AudioCodecSpecificData::_internal_ac4_ims_flag() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ac4_ims_flag_;
}
inline void MediaInfo_AudioCodecSpecificData::_internal_set_ac4_ims_flag(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.ac4_ims_flag_ = value;
}

// optional bool ac4_cbi_flag = 5;
inline bool MediaInfo_AudioCodecSpecificData::has_ac4_cbi_flag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void MediaInfo_AudioCodecSpecificData::clear_ac4_cbi_flag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ac4_cbi_flag_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool MediaInfo_AudioCodecSpecificData::ac4_cbi_flag() const {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.AudioCodecSpecificData.ac4_cbi_flag)
  return _internal_ac4_cbi_flag();
}
inline void MediaInfo_AudioCodecSpecificData::set_ac4_cbi_flag(bool value) {
  _internal_set_ac4_cbi_flag(value);
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.AudioCodecSpecificData.ac4_cbi_flag)
}
inline bool MediaInfo_AudioCodecSpecificData::_internal_ac4_cbi_flag() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ac4_cbi_flag_;
}
inline void MediaInfo_AudioCodecSpecificData::_internal_set_ac4_cbi_flag(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.ac4_cbi_flag_ = value;
}

// -------------------------------------------------------------------

// MediaInfo_TextInfo

// optional string codec = 1;
inline bool MediaInfo_TextInfo::has_codec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MediaInfo_TextInfo::clear_codec() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.codec_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MediaInfo_TextInfo::codec() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.TextInfo.codec)
  return _internal_codec();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MediaInfo_TextInfo::set_codec(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.codec_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.TextInfo.codec)
}
inline std::string* MediaInfo_TextInfo::mutable_codec() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_codec();
  // @@protoc_insertion_point(field_mutable:shaka.MediaInfo.TextInfo.codec)
  return _s;
}
inline const std::string& MediaInfo_TextInfo::_internal_codec() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.codec_.Get();
}
inline void MediaInfo_TextInfo::_internal_set_codec(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.codec_.Set(value, GetArena());
}
inline std::string* MediaInfo_TextInfo::_internal_mutable_codec() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.codec_.Mutable( GetArena());
}
inline std::string* MediaInfo_TextInfo::release_codec() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.MediaInfo.TextInfo.codec)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.codec_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.codec_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MediaInfo_TextInfo::set_allocated_codec(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.codec_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.codec_.IsDefault()) {
          _impl_.codec_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:shaka.MediaInfo.TextInfo.codec)
}

// optional string language = 2;
inline bool MediaInfo_TextInfo::has_language() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MediaInfo_TextInfo::clear_language() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.language_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MediaInfo_TextInfo::language() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.TextInfo.language)
  return _internal_language();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MediaInfo_TextInfo::set_language(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.language_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.TextInfo.language)
}
inline std::string* MediaInfo_TextInfo::mutable_language() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:shaka.MediaInfo.TextInfo.language)
  return _s;
}
inline const std::string& MediaInfo_TextInfo::_internal_language() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.language_.Get();
}
inline void MediaInfo_TextInfo::_internal_set_language(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.language_.Set(value, GetArena());
}
inline std::string* MediaInfo_TextInfo::_internal_mutable_language() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.language_.Mutable( GetArena());
}
inline std::string* MediaInfo_TextInfo::release_language() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.MediaInfo.TextInfo.language)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.language_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.language_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MediaInfo_TextInfo::set_allocated_language(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.language_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.language_.IsDefault()) {
          _impl_.language_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:shaka.MediaInfo.TextInfo.language)
}

// optional .shaka.MediaInfo.TextInfo.TextType type = 3;
inline bool MediaInfo_TextInfo::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MediaInfo_TextInfo::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::shaka::MediaInfo_TextInfo_TextType MediaInfo_TextInfo::type() const {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.TextInfo.type)
  return _internal_type();
}
inline void MediaInfo_TextInfo::set_type(::shaka::MediaInfo_TextInfo_TextType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.TextInfo.type)
}
inline ::shaka::MediaInfo_TextInfo_TextType MediaInfo_TextInfo::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::shaka::MediaInfo_TextInfo_TextType>(_impl_.type_);
}
inline void MediaInfo_TextInfo::_internal_set_type(::shaka::MediaInfo_TextInfo_TextType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::shaka::MediaInfo_TextInfo_TextType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.type_ = value;
}

// -------------------------------------------------------------------

// MediaInfo_ProtectedContent_ContentProtectionEntry

// optional string uuid = 1;
inline bool MediaInfo_ProtectedContent_ContentProtectionEntry::has_uuid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MediaInfo_ProtectedContent_ContentProtectionEntry::clear_uuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uuid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MediaInfo_ProtectedContent_ContentProtectionEntry::uuid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.ProtectedContent.ContentProtectionEntry.uuid)
  return _internal_uuid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MediaInfo_ProtectedContent_ContentProtectionEntry::set_uuid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.uuid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.ProtectedContent.ContentProtectionEntry.uuid)
}
inline std::string* MediaInfo_ProtectedContent_ContentProtectionEntry::mutable_uuid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:shaka.MediaInfo.ProtectedContent.ContentProtectionEntry.uuid)
  return _s;
}
inline const std::string& MediaInfo_ProtectedContent_ContentProtectionEntry::_internal_uuid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uuid_.Get();
}
inline void MediaInfo_ProtectedContent_ContentProtectionEntry::_internal_set_uuid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.uuid_.Set(value, GetArena());
}
inline std::string* MediaInfo_ProtectedContent_ContentProtectionEntry::_internal_mutable_uuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.uuid_.Mutable( GetArena());
}
inline std::string* MediaInfo_ProtectedContent_ContentProtectionEntry::release_uuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.MediaInfo.ProtectedContent.ContentProtectionEntry.uuid)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.uuid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.uuid_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MediaInfo_ProtectedContent_ContentProtectionEntry::set_allocated_uuid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.uuid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.uuid_.IsDefault()) {
          _impl_.uuid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:shaka.MediaInfo.ProtectedContent.ContentProtectionEntry.uuid)
}

// optional string name_version = 2;
inline bool MediaInfo_ProtectedContent_ContentProtectionEntry::has_name_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MediaInfo_ProtectedContent_ContentProtectionEntry::clear_name_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MediaInfo_ProtectedContent_ContentProtectionEntry::name_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.ProtectedContent.ContentProtectionEntry.name_version)
  return _internal_name_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MediaInfo_ProtectedContent_ContentProtectionEntry::set_name_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.ProtectedContent.ContentProtectionEntry.name_version)
}
inline std::string* MediaInfo_ProtectedContent_ContentProtectionEntry::mutable_name_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name_version();
  // @@protoc_insertion_point(field_mutable:shaka.MediaInfo.ProtectedContent.ContentProtectionEntry.name_version)
  return _s;
}
inline const std::string& MediaInfo_ProtectedContent_ContentProtectionEntry::_internal_name_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_version_.Get();
}
inline void MediaInfo_ProtectedContent_ContentProtectionEntry::_internal_set_name_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_version_.Set(value, GetArena());
}
inline std::string* MediaInfo_ProtectedContent_ContentProtectionEntry::_internal_mutable_name_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_version_.Mutable( GetArena());
}
inline std::string* MediaInfo_ProtectedContent_ContentProtectionEntry::release_name_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.MediaInfo.ProtectedContent.ContentProtectionEntry.name_version)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.name_version_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_version_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MediaInfo_ProtectedContent_ContentProtectionEntry::set_allocated_name_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_version_.IsDefault()) {
          _impl_.name_version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:shaka.MediaInfo.ProtectedContent.ContentProtectionEntry.name_version)
}

// optional bytes pssh = 3;
inline bool MediaInfo_ProtectedContent_ContentProtectionEntry::has_pssh() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MediaInfo_ProtectedContent_ContentProtectionEntry::clear_pssh() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pssh_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MediaInfo_ProtectedContent_ContentProtectionEntry::pssh() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.ProtectedContent.ContentProtectionEntry.pssh)
  return _internal_pssh();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MediaInfo_ProtectedContent_ContentProtectionEntry::set_pssh(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.pssh_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.ProtectedContent.ContentProtectionEntry.pssh)
}
inline std::string* MediaInfo_ProtectedContent_ContentProtectionEntry::mutable_pssh() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_pssh();
  // @@protoc_insertion_point(field_mutable:shaka.MediaInfo.ProtectedContent.ContentProtectionEntry.pssh)
  return _s;
}
inline const std::string& MediaInfo_ProtectedContent_ContentProtectionEntry::_internal_pssh() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pssh_.Get();
}
inline void MediaInfo_ProtectedContent_ContentProtectionEntry::_internal_set_pssh(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.pssh_.Set(value, GetArena());
}
inline std::string* MediaInfo_ProtectedContent_ContentProtectionEntry::_internal_mutable_pssh() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.pssh_.Mutable( GetArena());
}
inline std::string* MediaInfo_ProtectedContent_ContentProtectionEntry::release_pssh() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.MediaInfo.ProtectedContent.ContentProtectionEntry.pssh)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.pssh_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.pssh_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MediaInfo_ProtectedContent_ContentProtectionEntry::set_allocated_pssh(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.pssh_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.pssh_.IsDefault()) {
          _impl_.pssh_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:shaka.MediaInfo.ProtectedContent.ContentProtectionEntry.pssh)
}

// -------------------------------------------------------------------

// MediaInfo_ProtectedContent

// optional bytes default_key_id = 1;
inline bool MediaInfo_ProtectedContent::has_default_key_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MediaInfo_ProtectedContent::clear_default_key_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.default_key_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MediaInfo_ProtectedContent::default_key_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.ProtectedContent.default_key_id)
  return _internal_default_key_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MediaInfo_ProtectedContent::set_default_key_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.default_key_id_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.ProtectedContent.default_key_id)
}
inline std::string* MediaInfo_ProtectedContent::mutable_default_key_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_default_key_id();
  // @@protoc_insertion_point(field_mutable:shaka.MediaInfo.ProtectedContent.default_key_id)
  return _s;
}
inline const std::string& MediaInfo_ProtectedContent::_internal_default_key_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.default_key_id_.Get();
}
inline void MediaInfo_ProtectedContent::_internal_set_default_key_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.default_key_id_.Set(value, GetArena());
}
inline std::string* MediaInfo_ProtectedContent::_internal_mutable_default_key_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.default_key_id_.Mutable( GetArena());
}
inline std::string* MediaInfo_ProtectedContent::release_default_key_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.MediaInfo.ProtectedContent.default_key_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.default_key_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.default_key_id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MediaInfo_ProtectedContent::set_allocated_default_key_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.default_key_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.default_key_id_.IsDefault()) {
          _impl_.default_key_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:shaka.MediaInfo.ProtectedContent.default_key_id)
}

// repeated .shaka.MediaInfo.ProtectedContent.ContentProtectionEntry content_protection_entry = 2;
inline int MediaInfo_ProtectedContent::_internal_content_protection_entry_size() const {
  return _internal_content_protection_entry().size();
}
inline int MediaInfo_ProtectedContent::content_protection_entry_size() const {
  return _internal_content_protection_entry_size();
}
inline void MediaInfo_ProtectedContent::clear_content_protection_entry() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.content_protection_entry_.Clear();
}
inline ::shaka::MediaInfo_ProtectedContent_ContentProtectionEntry* MediaInfo_ProtectedContent::mutable_content_protection_entry(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:shaka.MediaInfo.ProtectedContent.content_protection_entry)
  return _internal_mutable_content_protection_entry()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::shaka::MediaInfo_ProtectedContent_ContentProtectionEntry>* MediaInfo_ProtectedContent::mutable_content_protection_entry()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:shaka.MediaInfo.ProtectedContent.content_protection_entry)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_content_protection_entry();
}
inline const ::shaka::MediaInfo_ProtectedContent_ContentProtectionEntry& MediaInfo_ProtectedContent::content_protection_entry(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.ProtectedContent.content_protection_entry)
  return _internal_content_protection_entry().Get(index);
}
inline ::shaka::MediaInfo_ProtectedContent_ContentProtectionEntry* MediaInfo_ProtectedContent::add_content_protection_entry() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::shaka::MediaInfo_ProtectedContent_ContentProtectionEntry* _add = _internal_mutable_content_protection_entry()->Add();
  // @@protoc_insertion_point(field_add:shaka.MediaInfo.ProtectedContent.content_protection_entry)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::shaka::MediaInfo_ProtectedContent_ContentProtectionEntry>& MediaInfo_ProtectedContent::content_protection_entry() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:shaka.MediaInfo.ProtectedContent.content_protection_entry)
  return _internal_content_protection_entry();
}
inline const ::google::protobuf::RepeatedPtrField<::shaka::MediaInfo_ProtectedContent_ContentProtectionEntry>&
MediaInfo_ProtectedContent::_internal_content_protection_entry() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.content_protection_entry_;
}
inline ::google::protobuf::RepeatedPtrField<::shaka::MediaInfo_ProtectedContent_ContentProtectionEntry>*
MediaInfo_ProtectedContent::_internal_mutable_content_protection_entry() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.content_protection_entry_;
}

// optional string protection_scheme = 3 [default = "cenc"];
inline bool MediaInfo_ProtectedContent::has_protection_scheme() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MediaInfo_ProtectedContent::clear_protection_scheme() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.protection_scheme_.ClearToDefault(::shaka::MediaInfo_ProtectedContent::Impl_::_i_give_permission_to_break_this_code_default_protection_scheme_, GetArena());
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MediaInfo_ProtectedContent::protection_scheme() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.ProtectedContent.protection_scheme)
  if (_impl_.protection_scheme_.IsDefault()) {
    return Impl_::_i_give_permission_to_break_this_code_default_protection_scheme_.get();
  }
  return _internal_protection_scheme();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MediaInfo_ProtectedContent::set_protection_scheme(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.protection_scheme_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.ProtectedContent.protection_scheme)
}
inline std::string* MediaInfo_ProtectedContent::mutable_protection_scheme() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_protection_scheme();
  // @@protoc_insertion_point(field_mutable:shaka.MediaInfo.ProtectedContent.protection_scheme)
  return _s;
}
inline const std::string& MediaInfo_ProtectedContent::_internal_protection_scheme() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.protection_scheme_.Get();
}
inline void MediaInfo_ProtectedContent::_internal_set_protection_scheme(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.protection_scheme_.Set(value, GetArena());
}
inline std::string* MediaInfo_ProtectedContent::_internal_mutable_protection_scheme() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.protection_scheme_.Mutable(::shaka::MediaInfo_ProtectedContent::Impl_::_i_give_permission_to_break_this_code_default_protection_scheme_, GetArena());
}
inline std::string* MediaInfo_ProtectedContent::release_protection_scheme() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.MediaInfo.ProtectedContent.protection_scheme)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  return _impl_.protection_scheme_.Release();
}
inline void MediaInfo_ProtectedContent::set_allocated_protection_scheme(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.protection_scheme_.SetAllocated(value, GetArena());
  // @@protoc_insertion_point(field_set_allocated:shaka.MediaInfo.ProtectedContent.protection_scheme)
}

// optional bool include_mspr_pro = 4 [default = true];
inline bool MediaInfo_ProtectedContent::has_include_mspr_pro() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MediaInfo_ProtectedContent::clear_include_mspr_pro() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.include_mspr_pro_ = true;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool MediaInfo_ProtectedContent::include_mspr_pro() const {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.ProtectedContent.include_mspr_pro)
  return _internal_include_mspr_pro();
}
inline void MediaInfo_ProtectedContent::set_include_mspr_pro(bool value) {
  _internal_set_include_mspr_pro(value);
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.ProtectedContent.include_mspr_pro)
}
inline bool MediaInfo_ProtectedContent::_internal_include_mspr_pro() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.include_mspr_pro_;
}
inline void MediaInfo_ProtectedContent::_internal_set_include_mspr_pro(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.include_mspr_pro_ = value;
}

// -------------------------------------------------------------------

// MediaInfo_ContentProtectionXml_AttributeNameValuePair

// optional string name = 1;
inline bool MediaInfo_ContentProtectionXml_AttributeNameValuePair::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MediaInfo_ContentProtectionXml_AttributeNameValuePair::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MediaInfo_ContentProtectionXml_AttributeNameValuePair::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.ContentProtectionXml.AttributeNameValuePair.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MediaInfo_ContentProtectionXml_AttributeNameValuePair::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.ContentProtectionXml.AttributeNameValuePair.name)
}
inline std::string* MediaInfo_ContentProtectionXml_AttributeNameValuePair::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:shaka.MediaInfo.ContentProtectionXml.AttributeNameValuePair.name)
  return _s;
}
inline const std::string& MediaInfo_ContentProtectionXml_AttributeNameValuePair::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void MediaInfo_ContentProtectionXml_AttributeNameValuePair::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* MediaInfo_ContentProtectionXml_AttributeNameValuePair::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* MediaInfo_ContentProtectionXml_AttributeNameValuePair::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.MediaInfo.ContentProtectionXml.AttributeNameValuePair.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MediaInfo_ContentProtectionXml_AttributeNameValuePair::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:shaka.MediaInfo.ContentProtectionXml.AttributeNameValuePair.name)
}

// optional string value = 2;
inline bool MediaInfo_ContentProtectionXml_AttributeNameValuePair::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MediaInfo_ContentProtectionXml_AttributeNameValuePair::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MediaInfo_ContentProtectionXml_AttributeNameValuePair::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.ContentProtectionXml.AttributeNameValuePair.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MediaInfo_ContentProtectionXml_AttributeNameValuePair::set_value(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.value_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.ContentProtectionXml.AttributeNameValuePair.value)
}
inline std::string* MediaInfo_ContentProtectionXml_AttributeNameValuePair::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:shaka.MediaInfo.ContentProtectionXml.AttributeNameValuePair.value)
  return _s;
}
inline const std::string& MediaInfo_ContentProtectionXml_AttributeNameValuePair::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_.Get();
}
inline void MediaInfo_ContentProtectionXml_AttributeNameValuePair::_internal_set_value(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.value_.Set(value, GetArena());
}
inline std::string* MediaInfo_ContentProtectionXml_AttributeNameValuePair::_internal_mutable_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.value_.Mutable( GetArena());
}
inline std::string* MediaInfo_ContentProtectionXml_AttributeNameValuePair::release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.MediaInfo.ContentProtectionXml.AttributeNameValuePair.value)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.value_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MediaInfo_ContentProtectionXml_AttributeNameValuePair::set_allocated_value(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.value_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:shaka.MediaInfo.ContentProtectionXml.AttributeNameValuePair.value)
}

// -------------------------------------------------------------------

// MediaInfo_ContentProtectionXml_Element

// optional string name = 1;
inline bool MediaInfo_ContentProtectionXml_Element::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MediaInfo_ContentProtectionXml_Element::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MediaInfo_ContentProtectionXml_Element::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.ContentProtectionXml.Element.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MediaInfo_ContentProtectionXml_Element::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.ContentProtectionXml.Element.name)
}
inline std::string* MediaInfo_ContentProtectionXml_Element::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:shaka.MediaInfo.ContentProtectionXml.Element.name)
  return _s;
}
inline const std::string& MediaInfo_ContentProtectionXml_Element::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void MediaInfo_ContentProtectionXml_Element::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* MediaInfo_ContentProtectionXml_Element::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* MediaInfo_ContentProtectionXml_Element::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.MediaInfo.ContentProtectionXml.Element.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MediaInfo_ContentProtectionXml_Element::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:shaka.MediaInfo.ContentProtectionXml.Element.name)
}

// repeated .shaka.MediaInfo.ContentProtectionXml.AttributeNameValuePair attributes = 2;
inline int MediaInfo_ContentProtectionXml_Element::_internal_attributes_size() const {
  return _internal_attributes().size();
}
inline int MediaInfo_ContentProtectionXml_Element::attributes_size() const {
  return _internal_attributes_size();
}
inline void MediaInfo_ContentProtectionXml_Element::clear_attributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.attributes_.Clear();
}
inline ::shaka::MediaInfo_ContentProtectionXml_AttributeNameValuePair* MediaInfo_ContentProtectionXml_Element::mutable_attributes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:shaka.MediaInfo.ContentProtectionXml.Element.attributes)
  return _internal_mutable_attributes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::shaka::MediaInfo_ContentProtectionXml_AttributeNameValuePair>* MediaInfo_ContentProtectionXml_Element::mutable_attributes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:shaka.MediaInfo.ContentProtectionXml.Element.attributes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_attributes();
}
inline const ::shaka::MediaInfo_ContentProtectionXml_AttributeNameValuePair& MediaInfo_ContentProtectionXml_Element::attributes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.ContentProtectionXml.Element.attributes)
  return _internal_attributes().Get(index);
}
inline ::shaka::MediaInfo_ContentProtectionXml_AttributeNameValuePair* MediaInfo_ContentProtectionXml_Element::add_attributes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::shaka::MediaInfo_ContentProtectionXml_AttributeNameValuePair* _add = _internal_mutable_attributes()->Add();
  // @@protoc_insertion_point(field_add:shaka.MediaInfo.ContentProtectionXml.Element.attributes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::shaka::MediaInfo_ContentProtectionXml_AttributeNameValuePair>& MediaInfo_ContentProtectionXml_Element::attributes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:shaka.MediaInfo.ContentProtectionXml.Element.attributes)
  return _internal_attributes();
}
inline const ::google::protobuf::RepeatedPtrField<::shaka::MediaInfo_ContentProtectionXml_AttributeNameValuePair>&
MediaInfo_ContentProtectionXml_Element::_internal_attributes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.attributes_;
}
inline ::google::protobuf::RepeatedPtrField<::shaka::MediaInfo_ContentProtectionXml_AttributeNameValuePair>*
MediaInfo_ContentProtectionXml_Element::_internal_mutable_attributes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.attributes_;
}

// repeated .shaka.MediaInfo.ContentProtectionXml.Element subelements = 3;
inline int MediaInfo_ContentProtectionXml_Element::_internal_subelements_size() const {
  return _internal_subelements().size();
}
inline int MediaInfo_ContentProtectionXml_Element::subelements_size() const {
  return _internal_subelements_size();
}
inline void MediaInfo_ContentProtectionXml_Element::clear_subelements() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.subelements_.Clear();
}
inline ::shaka::MediaInfo_ContentProtectionXml_Element* MediaInfo_ContentProtectionXml_Element::mutable_subelements(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:shaka.MediaInfo.ContentProtectionXml.Element.subelements)
  return _internal_mutable_subelements()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::shaka::MediaInfo_ContentProtectionXml_Element>* MediaInfo_ContentProtectionXml_Element::mutable_subelements()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:shaka.MediaInfo.ContentProtectionXml.Element.subelements)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_subelements();
}
inline const ::shaka::MediaInfo_ContentProtectionXml_Element& MediaInfo_ContentProtectionXml_Element::subelements(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.ContentProtectionXml.Element.subelements)
  return _internal_subelements().Get(index);
}
inline ::shaka::MediaInfo_ContentProtectionXml_Element* MediaInfo_ContentProtectionXml_Element::add_subelements() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::shaka::MediaInfo_ContentProtectionXml_Element* _add = _internal_mutable_subelements()->Add();
  // @@protoc_insertion_point(field_add:shaka.MediaInfo.ContentProtectionXml.Element.subelements)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::shaka::MediaInfo_ContentProtectionXml_Element>& MediaInfo_ContentProtectionXml_Element::subelements() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:shaka.MediaInfo.ContentProtectionXml.Element.subelements)
  return _internal_subelements();
}
inline const ::google::protobuf::RepeatedPtrField<::shaka::MediaInfo_ContentProtectionXml_Element>&
MediaInfo_ContentProtectionXml_Element::_internal_subelements() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.subelements_;
}
inline ::google::protobuf::RepeatedPtrField<::shaka::MediaInfo_ContentProtectionXml_Element>*
MediaInfo_ContentProtectionXml_Element::_internal_mutable_subelements() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.subelements_;
}

// -------------------------------------------------------------------

// MediaInfo_ContentProtectionXml

// optional string scheme_id_uri = 1;
inline bool MediaInfo_ContentProtectionXml::has_scheme_id_uri() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MediaInfo_ContentProtectionXml::clear_scheme_id_uri() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.scheme_id_uri_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MediaInfo_ContentProtectionXml::scheme_id_uri() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.ContentProtectionXml.scheme_id_uri)
  return _internal_scheme_id_uri();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MediaInfo_ContentProtectionXml::set_scheme_id_uri(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.scheme_id_uri_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.ContentProtectionXml.scheme_id_uri)
}
inline std::string* MediaInfo_ContentProtectionXml::mutable_scheme_id_uri() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_scheme_id_uri();
  // @@protoc_insertion_point(field_mutable:shaka.MediaInfo.ContentProtectionXml.scheme_id_uri)
  return _s;
}
inline const std::string& MediaInfo_ContentProtectionXml::_internal_scheme_id_uri() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.scheme_id_uri_.Get();
}
inline void MediaInfo_ContentProtectionXml::_internal_set_scheme_id_uri(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.scheme_id_uri_.Set(value, GetArena());
}
inline std::string* MediaInfo_ContentProtectionXml::_internal_mutable_scheme_id_uri() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.scheme_id_uri_.Mutable( GetArena());
}
inline std::string* MediaInfo_ContentProtectionXml::release_scheme_id_uri() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.MediaInfo.ContentProtectionXml.scheme_id_uri)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.scheme_id_uri_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.scheme_id_uri_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MediaInfo_ContentProtectionXml::set_allocated_scheme_id_uri(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.scheme_id_uri_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.scheme_id_uri_.IsDefault()) {
          _impl_.scheme_id_uri_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:shaka.MediaInfo.ContentProtectionXml.scheme_id_uri)
}

// optional string value = 2;
inline bool MediaInfo_ContentProtectionXml::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MediaInfo_ContentProtectionXml::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MediaInfo_ContentProtectionXml::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.ContentProtectionXml.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MediaInfo_ContentProtectionXml::set_value(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.value_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.ContentProtectionXml.value)
}
inline std::string* MediaInfo_ContentProtectionXml::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:shaka.MediaInfo.ContentProtectionXml.value)
  return _s;
}
inline const std::string& MediaInfo_ContentProtectionXml::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_.Get();
}
inline void MediaInfo_ContentProtectionXml::_internal_set_value(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.value_.Set(value, GetArena());
}
inline std::string* MediaInfo_ContentProtectionXml::_internal_mutable_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.value_.Mutable( GetArena());
}
inline std::string* MediaInfo_ContentProtectionXml::release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.MediaInfo.ContentProtectionXml.value)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.value_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MediaInfo_ContentProtectionXml::set_allocated_value(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.value_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:shaka.MediaInfo.ContentProtectionXml.value)
}

// repeated .shaka.MediaInfo.ContentProtectionXml.AttributeNameValuePair attributes = 3;
inline int MediaInfo_ContentProtectionXml::_internal_attributes_size() const {
  return _internal_attributes().size();
}
inline int MediaInfo_ContentProtectionXml::attributes_size() const {
  return _internal_attributes_size();
}
inline void MediaInfo_ContentProtectionXml::clear_attributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.attributes_.Clear();
}
inline ::shaka::MediaInfo_ContentProtectionXml_AttributeNameValuePair* MediaInfo_ContentProtectionXml::mutable_attributes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:shaka.MediaInfo.ContentProtectionXml.attributes)
  return _internal_mutable_attributes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::shaka::MediaInfo_ContentProtectionXml_AttributeNameValuePair>* MediaInfo_ContentProtectionXml::mutable_attributes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:shaka.MediaInfo.ContentProtectionXml.attributes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_attributes();
}
inline const ::shaka::MediaInfo_ContentProtectionXml_AttributeNameValuePair& MediaInfo_ContentProtectionXml::attributes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.ContentProtectionXml.attributes)
  return _internal_attributes().Get(index);
}
inline ::shaka::MediaInfo_ContentProtectionXml_AttributeNameValuePair* MediaInfo_ContentProtectionXml::add_attributes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::shaka::MediaInfo_ContentProtectionXml_AttributeNameValuePair* _add = _internal_mutable_attributes()->Add();
  // @@protoc_insertion_point(field_add:shaka.MediaInfo.ContentProtectionXml.attributes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::shaka::MediaInfo_ContentProtectionXml_AttributeNameValuePair>& MediaInfo_ContentProtectionXml::attributes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:shaka.MediaInfo.ContentProtectionXml.attributes)
  return _internal_attributes();
}
inline const ::google::protobuf::RepeatedPtrField<::shaka::MediaInfo_ContentProtectionXml_AttributeNameValuePair>&
MediaInfo_ContentProtectionXml::_internal_attributes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.attributes_;
}
inline ::google::protobuf::RepeatedPtrField<::shaka::MediaInfo_ContentProtectionXml_AttributeNameValuePair>*
MediaInfo_ContentProtectionXml::_internal_mutable_attributes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.attributes_;
}

// repeated .shaka.MediaInfo.ContentProtectionXml.Element subelements = 4;
inline int MediaInfo_ContentProtectionXml::_internal_subelements_size() const {
  return _internal_subelements().size();
}
inline int MediaInfo_ContentProtectionXml::subelements_size() const {
  return _internal_subelements_size();
}
inline void MediaInfo_ContentProtectionXml::clear_subelements() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.subelements_.Clear();
}
inline ::shaka::MediaInfo_ContentProtectionXml_Element* MediaInfo_ContentProtectionXml::mutable_subelements(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:shaka.MediaInfo.ContentProtectionXml.subelements)
  return _internal_mutable_subelements()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::shaka::MediaInfo_ContentProtectionXml_Element>* MediaInfo_ContentProtectionXml::mutable_subelements()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:shaka.MediaInfo.ContentProtectionXml.subelements)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_subelements();
}
inline const ::shaka::MediaInfo_ContentProtectionXml_Element& MediaInfo_ContentProtectionXml::subelements(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.ContentProtectionXml.subelements)
  return _internal_subelements().Get(index);
}
inline ::shaka::MediaInfo_ContentProtectionXml_Element* MediaInfo_ContentProtectionXml::add_subelements() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::shaka::MediaInfo_ContentProtectionXml_Element* _add = _internal_mutable_subelements()->Add();
  // @@protoc_insertion_point(field_add:shaka.MediaInfo.ContentProtectionXml.subelements)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::shaka::MediaInfo_ContentProtectionXml_Element>& MediaInfo_ContentProtectionXml::subelements() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:shaka.MediaInfo.ContentProtectionXml.subelements)
  return _internal_subelements();
}
inline const ::google::protobuf::RepeatedPtrField<::shaka::MediaInfo_ContentProtectionXml_Element>&
MediaInfo_ContentProtectionXml::_internal_subelements() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.subelements_;
}
inline ::google::protobuf::RepeatedPtrField<::shaka::MediaInfo_ContentProtectionXml_Element>*
MediaInfo_ContentProtectionXml::_internal_mutable_subelements() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.subelements_;
}

// -------------------------------------------------------------------

// MediaInfo

// optional uint32 bandwidth = 1;
inline bool MediaInfo::has_bandwidth() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void MediaInfo::clear_bandwidth() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bandwidth_ = 0u;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline ::uint32_t MediaInfo::bandwidth() const {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.bandwidth)
  return _internal_bandwidth();
}
inline void MediaInfo::set_bandwidth(::uint32_t value) {
  _internal_set_bandwidth(value);
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.bandwidth)
}
inline ::uint32_t MediaInfo::_internal_bandwidth() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.bandwidth_;
}
inline void MediaInfo::_internal_set_bandwidth(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.bandwidth_ = value;
}

// optional .shaka.MediaInfo.VideoInfo video_info = 2;
inline bool MediaInfo::has_video_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.video_info_ != nullptr);
  return value;
}
inline void MediaInfo::clear_video_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.video_info_ != nullptr) _impl_.video_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::shaka::MediaInfo_VideoInfo& MediaInfo::_internal_video_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::shaka::MediaInfo_VideoInfo* p = _impl_.video_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::shaka::MediaInfo_VideoInfo&>(::shaka::_MediaInfo_VideoInfo_default_instance_);
}
inline const ::shaka::MediaInfo_VideoInfo& MediaInfo::video_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.video_info)
  return _internal_video_info();
}
inline void MediaInfo::unsafe_arena_set_allocated_video_info(::shaka::MediaInfo_VideoInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.video_info_);
  }
  _impl_.video_info_ = reinterpret_cast<::shaka::MediaInfo_VideoInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:shaka.MediaInfo.video_info)
}
inline ::shaka::MediaInfo_VideoInfo* MediaInfo::release_video_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::shaka::MediaInfo_VideoInfo* released = _impl_.video_info_;
  _impl_.video_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::shaka::MediaInfo_VideoInfo* MediaInfo::unsafe_arena_release_video_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.MediaInfo.video_info)

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::shaka::MediaInfo_VideoInfo* temp = _impl_.video_info_;
  _impl_.video_info_ = nullptr;
  return temp;
}
inline ::shaka::MediaInfo_VideoInfo* MediaInfo::_internal_mutable_video_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.video_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::shaka::MediaInfo_VideoInfo>(GetArena());
    _impl_.video_info_ = reinterpret_cast<::shaka::MediaInfo_VideoInfo*>(p);
  }
  return _impl_.video_info_;
}
inline ::shaka::MediaInfo_VideoInfo* MediaInfo::mutable_video_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::shaka::MediaInfo_VideoInfo* _msg = _internal_mutable_video_info();
  // @@protoc_insertion_point(field_mutable:shaka.MediaInfo.video_info)
  return _msg;
}
inline void MediaInfo::set_allocated_video_info(::shaka::MediaInfo_VideoInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::shaka::MediaInfo_VideoInfo*>(_impl_.video_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::shaka::MediaInfo_VideoInfo*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }

  _impl_.video_info_ = reinterpret_cast<::shaka::MediaInfo_VideoInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:shaka.MediaInfo.video_info)
}

// optional .shaka.MediaInfo.AudioInfo audio_info = 3;
inline bool MediaInfo::has_audio_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.audio_info_ != nullptr);
  return value;
}
inline void MediaInfo::clear_audio_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.audio_info_ != nullptr) _impl_.audio_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::shaka::MediaInfo_AudioInfo& MediaInfo::_internal_audio_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::shaka::MediaInfo_AudioInfo* p = _impl_.audio_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::shaka::MediaInfo_AudioInfo&>(::shaka::_MediaInfo_AudioInfo_default_instance_);
}
inline const ::shaka::MediaInfo_AudioInfo& MediaInfo::audio_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.audio_info)
  return _internal_audio_info();
}
inline void MediaInfo::unsafe_arena_set_allocated_audio_info(::shaka::MediaInfo_AudioInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.audio_info_);
  }
  _impl_.audio_info_ = reinterpret_cast<::shaka::MediaInfo_AudioInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:shaka.MediaInfo.audio_info)
}
inline ::shaka::MediaInfo_AudioInfo* MediaInfo::release_audio_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::shaka::MediaInfo_AudioInfo* released = _impl_.audio_info_;
  _impl_.audio_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::shaka::MediaInfo_AudioInfo* MediaInfo::unsafe_arena_release_audio_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.MediaInfo.audio_info)

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::shaka::MediaInfo_AudioInfo* temp = _impl_.audio_info_;
  _impl_.audio_info_ = nullptr;
  return temp;
}
inline ::shaka::MediaInfo_AudioInfo* MediaInfo::_internal_mutable_audio_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.audio_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::shaka::MediaInfo_AudioInfo>(GetArena());
    _impl_.audio_info_ = reinterpret_cast<::shaka::MediaInfo_AudioInfo*>(p);
  }
  return _impl_.audio_info_;
}
inline ::shaka::MediaInfo_AudioInfo* MediaInfo::mutable_audio_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::shaka::MediaInfo_AudioInfo* _msg = _internal_mutable_audio_info();
  // @@protoc_insertion_point(field_mutable:shaka.MediaInfo.audio_info)
  return _msg;
}
inline void MediaInfo::set_allocated_audio_info(::shaka::MediaInfo_AudioInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::shaka::MediaInfo_AudioInfo*>(_impl_.audio_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::shaka::MediaInfo_AudioInfo*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }

  _impl_.audio_info_ = reinterpret_cast<::shaka::MediaInfo_AudioInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:shaka.MediaInfo.audio_info)
}

// optional .shaka.MediaInfo.TextInfo text_info = 4;
inline bool MediaInfo::has_text_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.text_info_ != nullptr);
  return value;
}
inline void MediaInfo::clear_text_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.text_info_ != nullptr) _impl_.text_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::shaka::MediaInfo_TextInfo& MediaInfo::_internal_text_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::shaka::MediaInfo_TextInfo* p = _impl_.text_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::shaka::MediaInfo_TextInfo&>(::shaka::_MediaInfo_TextInfo_default_instance_);
}
inline const ::shaka::MediaInfo_TextInfo& MediaInfo::text_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.text_info)
  return _internal_text_info();
}
inline void MediaInfo::unsafe_arena_set_allocated_text_info(::shaka::MediaInfo_TextInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.text_info_);
  }
  _impl_.text_info_ = reinterpret_cast<::shaka::MediaInfo_TextInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:shaka.MediaInfo.text_info)
}
inline ::shaka::MediaInfo_TextInfo* MediaInfo::release_text_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::shaka::MediaInfo_TextInfo* released = _impl_.text_info_;
  _impl_.text_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::shaka::MediaInfo_TextInfo* MediaInfo::unsafe_arena_release_text_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.MediaInfo.text_info)

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::shaka::MediaInfo_TextInfo* temp = _impl_.text_info_;
  _impl_.text_info_ = nullptr;
  return temp;
}
inline ::shaka::MediaInfo_TextInfo* MediaInfo::_internal_mutable_text_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.text_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::shaka::MediaInfo_TextInfo>(GetArena());
    _impl_.text_info_ = reinterpret_cast<::shaka::MediaInfo_TextInfo*>(p);
  }
  return _impl_.text_info_;
}
inline ::shaka::MediaInfo_TextInfo* MediaInfo::mutable_text_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::shaka::MediaInfo_TextInfo* _msg = _internal_mutable_text_info();
  // @@protoc_insertion_point(field_mutable:shaka.MediaInfo.text_info)
  return _msg;
}
inline void MediaInfo::set_allocated_text_info(::shaka::MediaInfo_TextInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::shaka::MediaInfo_TextInfo*>(_impl_.text_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::shaka::MediaInfo_TextInfo*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }

  _impl_.text_info_ = reinterpret_cast<::shaka::MediaInfo_TextInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:shaka.MediaInfo.text_info)
}

// repeated .shaka.MediaInfo.ContentProtectionXml content_protections = 5;
inline int MediaInfo::_internal_content_protections_size() const {
  return _internal_content_protections().size();
}
inline int MediaInfo::content_protections_size() const {
  return _internal_content_protections_size();
}
inline void MediaInfo::clear_content_protections() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.content_protections_.Clear();
}
inline ::shaka::MediaInfo_ContentProtectionXml* MediaInfo::mutable_content_protections(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:shaka.MediaInfo.content_protections)
  return _internal_mutable_content_protections()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::shaka::MediaInfo_ContentProtectionXml>* MediaInfo::mutable_content_protections()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:shaka.MediaInfo.content_protections)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_content_protections();
}
inline const ::shaka::MediaInfo_ContentProtectionXml& MediaInfo::content_protections(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.content_protections)
  return _internal_content_protections().Get(index);
}
inline ::shaka::MediaInfo_ContentProtectionXml* MediaInfo::add_content_protections() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::shaka::MediaInfo_ContentProtectionXml* _add = _internal_mutable_content_protections()->Add();
  // @@protoc_insertion_point(field_add:shaka.MediaInfo.content_protections)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::shaka::MediaInfo_ContentProtectionXml>& MediaInfo::content_protections() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:shaka.MediaInfo.content_protections)
  return _internal_content_protections();
}
inline const ::google::protobuf::RepeatedPtrField<::shaka::MediaInfo_ContentProtectionXml>&
MediaInfo::_internal_content_protections() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.content_protections_;
}
inline ::google::protobuf::RepeatedPtrField<::shaka::MediaInfo_ContentProtectionXml>*
MediaInfo::_internal_mutable_content_protections() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.content_protections_;
}

// optional .shaka.MediaInfo.ProtectedContent protected_content = 15;
inline bool MediaInfo::has_protected_content() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.protected_content_ != nullptr);
  return value;
}
inline void MediaInfo::clear_protected_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.protected_content_ != nullptr) _impl_.protected_content_->Clear();
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline const ::shaka::MediaInfo_ProtectedContent& MediaInfo::_internal_protected_content() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::shaka::MediaInfo_ProtectedContent* p = _impl_.protected_content_;
  return p != nullptr ? *p : reinterpret_cast<const ::shaka::MediaInfo_ProtectedContent&>(::shaka::_MediaInfo_ProtectedContent_default_instance_);
}
inline const ::shaka::MediaInfo_ProtectedContent& MediaInfo::protected_content() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.protected_content)
  return _internal_protected_content();
}
inline void MediaInfo::unsafe_arena_set_allocated_protected_content(::shaka::MediaInfo_ProtectedContent* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.protected_content_);
  }
  _impl_.protected_content_ = reinterpret_cast<::shaka::MediaInfo_ProtectedContent*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:shaka.MediaInfo.protected_content)
}
inline ::shaka::MediaInfo_ProtectedContent* MediaInfo::release_protected_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00001000u;
  ::shaka::MediaInfo_ProtectedContent* released = _impl_.protected_content_;
  _impl_.protected_content_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::shaka::MediaInfo_ProtectedContent* MediaInfo::unsafe_arena_release_protected_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.MediaInfo.protected_content)

  _impl_._has_bits_[0] &= ~0x00001000u;
  ::shaka::MediaInfo_ProtectedContent* temp = _impl_.protected_content_;
  _impl_.protected_content_ = nullptr;
  return temp;
}
inline ::shaka::MediaInfo_ProtectedContent* MediaInfo::_internal_mutable_protected_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00001000u;
  if (_impl_.protected_content_ == nullptr) {
    auto* p = CreateMaybeMessage<::shaka::MediaInfo_ProtectedContent>(GetArena());
    _impl_.protected_content_ = reinterpret_cast<::shaka::MediaInfo_ProtectedContent*>(p);
  }
  return _impl_.protected_content_;
}
inline ::shaka::MediaInfo_ProtectedContent* MediaInfo::mutable_protected_content() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::shaka::MediaInfo_ProtectedContent* _msg = _internal_mutable_protected_content();
  // @@protoc_insertion_point(field_mutable:shaka.MediaInfo.protected_content)
  return _msg;
}
inline void MediaInfo::set_allocated_protected_content(::shaka::MediaInfo_ProtectedContent* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::shaka::MediaInfo_ProtectedContent*>(_impl_.protected_content_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::shaka::MediaInfo_ProtectedContent*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }

  _impl_.protected_content_ = reinterpret_cast<::shaka::MediaInfo_ProtectedContent*>(value);
  // @@protoc_insertion_point(field_set_allocated:shaka.MediaInfo.protected_content)
}

// optional uint32 reference_time_scale = 13;
inline bool MediaInfo::has_reference_time_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline void MediaInfo::clear_reference_time_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reference_time_scale_ = 0u;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline ::uint32_t MediaInfo::reference_time_scale() const {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.reference_time_scale)
  return _internal_reference_time_scale();
}
inline void MediaInfo::set_reference_time_scale(::uint32_t value) {
  _internal_set_reference_time_scale(value);
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.reference_time_scale)
}
inline ::uint32_t MediaInfo::_internal_reference_time_scale() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.reference_time_scale_;
}
inline void MediaInfo::_internal_set_reference_time_scale(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.reference_time_scale_ = value;
}

// optional uint64 presentation_time_offset = 16;
inline bool MediaInfo::has_presentation_time_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline void MediaInfo::clear_presentation_time_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.presentation_time_offset_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline ::uint64_t MediaInfo::presentation_time_offset() const {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.presentation_time_offset)
  return _internal_presentation_time_offset();
}
inline void MediaInfo::set_presentation_time_offset(::uint64_t value) {
  _internal_set_presentation_time_offset(value);
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.presentation_time_offset)
}
inline ::uint64_t MediaInfo::_internal_presentation_time_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.presentation_time_offset_;
}
inline void MediaInfo::_internal_set_presentation_time_offset(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.presentation_time_offset_ = value;
}

// optional .shaka.MediaInfo.ContainerType container_type = 14 [default = CONTAINER_UNKNOWN];
inline bool MediaInfo::has_container_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline void MediaInfo::clear_container_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.container_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline ::shaka::MediaInfo_ContainerType MediaInfo::container_type() const {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.container_type)
  return _internal_container_type();
}
inline void MediaInfo::set_container_type(::shaka::MediaInfo_ContainerType value) {
  _internal_set_container_type(value);
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.container_type)
}
inline ::shaka::MediaInfo_ContainerType MediaInfo::_internal_container_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::shaka::MediaInfo_ContainerType>(_impl_.container_type_);
}
inline void MediaInfo::_internal_set_container_type(::shaka::MediaInfo_ContainerType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::shaka::MediaInfo_ContainerType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.container_type_ = value;
}

// optional .shaka.Range init_range = 6;
inline bool MediaInfo::has_init_range() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.init_range_ != nullptr);
  return value;
}
inline void MediaInfo::clear_init_range() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.init_range_ != nullptr) _impl_.init_range_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const ::shaka::Range& MediaInfo::_internal_init_range() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::shaka::Range* p = _impl_.init_range_;
  return p != nullptr ? *p : reinterpret_cast<const ::shaka::Range&>(::shaka::_Range_default_instance_);
}
inline const ::shaka::Range& MediaInfo::init_range() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.init_range)
  return _internal_init_range();
}
inline void MediaInfo::unsafe_arena_set_allocated_init_range(::shaka::Range* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.init_range_);
  }
  _impl_.init_range_ = reinterpret_cast<::shaka::Range*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:shaka.MediaInfo.init_range)
}
inline ::shaka::Range* MediaInfo::release_init_range() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000400u;
  ::shaka::Range* released = _impl_.init_range_;
  _impl_.init_range_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::shaka::Range* MediaInfo::unsafe_arena_release_init_range() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.MediaInfo.init_range)

  _impl_._has_bits_[0] &= ~0x00000400u;
  ::shaka::Range* temp = _impl_.init_range_;
  _impl_.init_range_ = nullptr;
  return temp;
}
inline ::shaka::Range* MediaInfo::_internal_mutable_init_range() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.init_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::shaka::Range>(GetArena());
    _impl_.init_range_ = reinterpret_cast<::shaka::Range*>(p);
  }
  return _impl_.init_range_;
}
inline ::shaka::Range* MediaInfo::mutable_init_range() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::shaka::Range* _msg = _internal_mutable_init_range();
  // @@protoc_insertion_point(field_mutable:shaka.MediaInfo.init_range)
  return _msg;
}
inline void MediaInfo::set_allocated_init_range(::shaka::Range* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::shaka::Range*>(_impl_.init_range_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::shaka::Range*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }

  _impl_.init_range_ = reinterpret_cast<::shaka::Range*>(value);
  // @@protoc_insertion_point(field_set_allocated:shaka.MediaInfo.init_range)
}

// optional .shaka.Range index_range = 7;
inline bool MediaInfo::has_index_range() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.index_range_ != nullptr);
  return value;
}
inline void MediaInfo::clear_index_range() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.index_range_ != nullptr) _impl_.index_range_->Clear();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const ::shaka::Range& MediaInfo::_internal_index_range() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::shaka::Range* p = _impl_.index_range_;
  return p != nullptr ? *p : reinterpret_cast<const ::shaka::Range&>(::shaka::_Range_default_instance_);
}
inline const ::shaka::Range& MediaInfo::index_range() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.index_range)
  return _internal_index_range();
}
inline void MediaInfo::unsafe_arena_set_allocated_index_range(::shaka::Range* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.index_range_);
  }
  _impl_.index_range_ = reinterpret_cast<::shaka::Range*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:shaka.MediaInfo.index_range)
}
inline ::shaka::Range* MediaInfo::release_index_range() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000800u;
  ::shaka::Range* released = _impl_.index_range_;
  _impl_.index_range_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::shaka::Range* MediaInfo::unsafe_arena_release_index_range() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.MediaInfo.index_range)

  _impl_._has_bits_[0] &= ~0x00000800u;
  ::shaka::Range* temp = _impl_.index_range_;
  _impl_.index_range_ = nullptr;
  return temp;
}
inline ::shaka::Range* MediaInfo::_internal_mutable_index_range() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000800u;
  if (_impl_.index_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::shaka::Range>(GetArena());
    _impl_.index_range_ = reinterpret_cast<::shaka::Range*>(p);
  }
  return _impl_.index_range_;
}
inline ::shaka::Range* MediaInfo::mutable_index_range() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::shaka::Range* _msg = _internal_mutable_index_range();
  // @@protoc_insertion_point(field_mutable:shaka.MediaInfo.index_range)
  return _msg;
}
inline void MediaInfo::set_allocated_index_range(::shaka::Range* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::shaka::Range*>(_impl_.index_range_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::shaka::Range*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }

  _impl_.index_range_ = reinterpret_cast<::shaka::Range*>(value);
  // @@protoc_insertion_point(field_set_allocated:shaka.MediaInfo.index_range)
}

// optional string media_file_name = 8;
inline bool MediaInfo::has_media_file_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MediaInfo::clear_media_file_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.media_file_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MediaInfo::media_file_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.media_file_name)
  return _internal_media_file_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MediaInfo::set_media_file_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.media_file_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.media_file_name)
}
inline std::string* MediaInfo::mutable_media_file_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_media_file_name();
  // @@protoc_insertion_point(field_mutable:shaka.MediaInfo.media_file_name)
  return _s;
}
inline const std::string& MediaInfo::_internal_media_file_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.media_file_name_.Get();
}
inline void MediaInfo::_internal_set_media_file_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.media_file_name_.Set(value, GetArena());
}
inline std::string* MediaInfo::_internal_mutable_media_file_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.media_file_name_.Mutable( GetArena());
}
inline std::string* MediaInfo::release_media_file_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.MediaInfo.media_file_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.media_file_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.media_file_name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MediaInfo::set_allocated_media_file_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.media_file_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.media_file_name_.IsDefault()) {
          _impl_.media_file_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:shaka.MediaInfo.media_file_name)
}

// repeated .shaka.Range subsegment_ranges = 23;
inline int MediaInfo::_internal_subsegment_ranges_size() const {
  return _internal_subsegment_ranges().size();
}
inline int MediaInfo::subsegment_ranges_size() const {
  return _internal_subsegment_ranges_size();
}
inline void MediaInfo::clear_subsegment_ranges() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.subsegment_ranges_.Clear();
}
inline ::shaka::Range* MediaInfo::mutable_subsegment_ranges(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:shaka.MediaInfo.subsegment_ranges)
  return _internal_mutable_subsegment_ranges()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::shaka::Range>* MediaInfo::mutable_subsegment_ranges()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:shaka.MediaInfo.subsegment_ranges)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_subsegment_ranges();
}
inline const ::shaka::Range& MediaInfo::subsegment_ranges(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.subsegment_ranges)
  return _internal_subsegment_ranges().Get(index);
}
inline ::shaka::Range* MediaInfo::add_subsegment_ranges() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::shaka::Range* _add = _internal_mutable_subsegment_ranges()->Add();
  // @@protoc_insertion_point(field_add:shaka.MediaInfo.subsegment_ranges)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::shaka::Range>& MediaInfo::subsegment_ranges() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:shaka.MediaInfo.subsegment_ranges)
  return _internal_subsegment_ranges();
}
inline const ::google::protobuf::RepeatedPtrField<::shaka::Range>&
MediaInfo::_internal_subsegment_ranges() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.subsegment_ranges_;
}
inline ::google::protobuf::RepeatedPtrField<::shaka::Range>*
MediaInfo::_internal_mutable_subsegment_ranges() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.subsegment_ranges_;
}

// optional float media_duration_seconds = 9;
inline bool MediaInfo::has_media_duration_seconds() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline void MediaInfo::clear_media_duration_seconds() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.media_duration_seconds_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline float MediaInfo::media_duration_seconds() const {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.media_duration_seconds)
  return _internal_media_duration_seconds();
}
inline void MediaInfo::set_media_duration_seconds(float value) {
  _internal_set_media_duration_seconds(value);
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.media_duration_seconds)
}
inline float MediaInfo::_internal_media_duration_seconds() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.media_duration_seconds_;
}
inline void MediaInfo::_internal_set_media_duration_seconds(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.media_duration_seconds_ = value;
}

// optional string init_segment_name = 10;
inline bool MediaInfo::has_init_segment_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MediaInfo::clear_init_segment_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.init_segment_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MediaInfo::init_segment_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.init_segment_name)
  return _internal_init_segment_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MediaInfo::set_init_segment_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.init_segment_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.init_segment_name)
}
inline std::string* MediaInfo::mutable_init_segment_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_init_segment_name();
  // @@protoc_insertion_point(field_mutable:shaka.MediaInfo.init_segment_name)
  return _s;
}
inline const std::string& MediaInfo::_internal_init_segment_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.init_segment_name_.Get();
}
inline void MediaInfo::_internal_set_init_segment_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.init_segment_name_.Set(value, GetArena());
}
inline std::string* MediaInfo::_internal_mutable_init_segment_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.init_segment_name_.Mutable( GetArena());
}
inline std::string* MediaInfo::release_init_segment_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.MediaInfo.init_segment_name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.init_segment_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.init_segment_name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MediaInfo::set_allocated_init_segment_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.init_segment_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.init_segment_name_.IsDefault()) {
          _impl_.init_segment_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:shaka.MediaInfo.init_segment_name)
}

// optional string segment_template = 11;
inline bool MediaInfo::has_segment_template() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MediaInfo::clear_segment_template() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.segment_template_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MediaInfo::segment_template() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.segment_template)
  return _internal_segment_template();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MediaInfo::set_segment_template(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.segment_template_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.segment_template)
}
inline std::string* MediaInfo::mutable_segment_template() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_segment_template();
  // @@protoc_insertion_point(field_mutable:shaka.MediaInfo.segment_template)
  return _s;
}
inline const std::string& MediaInfo::_internal_segment_template() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.segment_template_.Get();
}
inline void MediaInfo::_internal_set_segment_template(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.segment_template_.Set(value, GetArena());
}
inline std::string* MediaInfo::_internal_mutable_segment_template() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.segment_template_.Mutable( GetArena());
}
inline std::string* MediaInfo::release_segment_template() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.MediaInfo.segment_template)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.segment_template_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.segment_template_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MediaInfo::set_allocated_segment_template(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.segment_template_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.segment_template_.IsDefault()) {
          _impl_.segment_template_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:shaka.MediaInfo.segment_template)
}

// optional float segment_duration_seconds = 12 [deprecated = true];
inline bool MediaInfo::has_segment_duration_seconds() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline void MediaInfo::clear_segment_duration_seconds() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.segment_duration_seconds_ = 0;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline float MediaInfo::segment_duration_seconds() const {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.segment_duration_seconds)
  return _internal_segment_duration_seconds();
}
inline void MediaInfo::set_segment_duration_seconds(float value) {
  _internal_set_segment_duration_seconds(value);
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.segment_duration_seconds)
}
inline float MediaInfo::_internal_segment_duration_seconds() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.segment_duration_seconds_;
}
inline void MediaInfo::_internal_set_segment_duration_seconds(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.segment_duration_seconds_ = value;
}

// optional string media_file_url = 17;
inline bool MediaInfo::has_media_file_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void MediaInfo::clear_media_file_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.media_file_url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& MediaInfo::media_file_url() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.media_file_url)
  return _internal_media_file_url();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MediaInfo::set_media_file_url(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.media_file_url_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.media_file_url)
}
inline std::string* MediaInfo::mutable_media_file_url() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_media_file_url();
  // @@protoc_insertion_point(field_mutable:shaka.MediaInfo.media_file_url)
  return _s;
}
inline const std::string& MediaInfo::_internal_media_file_url() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.media_file_url_.Get();
}
inline void MediaInfo::_internal_set_media_file_url(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.media_file_url_.Set(value, GetArena());
}
inline std::string* MediaInfo::_internal_mutable_media_file_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.media_file_url_.Mutable( GetArena());
}
inline std::string* MediaInfo::release_media_file_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.MediaInfo.media_file_url)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.media_file_url_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.media_file_url_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MediaInfo::set_allocated_media_file_url(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.media_file_url_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.media_file_url_.IsDefault()) {
          _impl_.media_file_url_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:shaka.MediaInfo.media_file_url)
}

// optional string init_segment_url = 18;
inline bool MediaInfo::has_init_segment_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void MediaInfo::clear_init_segment_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.init_segment_url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& MediaInfo::init_segment_url() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.init_segment_url)
  return _internal_init_segment_url();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MediaInfo::set_init_segment_url(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.init_segment_url_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.init_segment_url)
}
inline std::string* MediaInfo::mutable_init_segment_url() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_init_segment_url();
  // @@protoc_insertion_point(field_mutable:shaka.MediaInfo.init_segment_url)
  return _s;
}
inline const std::string& MediaInfo::_internal_init_segment_url() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.init_segment_url_.Get();
}
inline void MediaInfo::_internal_set_init_segment_url(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.init_segment_url_.Set(value, GetArena());
}
inline std::string* MediaInfo::_internal_mutable_init_segment_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.init_segment_url_.Mutable( GetArena());
}
inline std::string* MediaInfo::release_init_segment_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.MediaInfo.init_segment_url)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.init_segment_url_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.init_segment_url_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MediaInfo::set_allocated_init_segment_url(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.init_segment_url_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.init_segment_url_.IsDefault()) {
          _impl_.init_segment_url_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:shaka.MediaInfo.init_segment_url)
}

// optional string segment_template_url = 19;
inline bool MediaInfo::has_segment_template_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void MediaInfo::clear_segment_template_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.segment_template_url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& MediaInfo::segment_template_url() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.segment_template_url)
  return _internal_segment_template_url();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MediaInfo::set_segment_template_url(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.segment_template_url_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.segment_template_url)
}
inline std::string* MediaInfo::mutable_segment_template_url() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_segment_template_url();
  // @@protoc_insertion_point(field_mutable:shaka.MediaInfo.segment_template_url)
  return _s;
}
inline const std::string& MediaInfo::_internal_segment_template_url() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.segment_template_url_.Get();
}
inline void MediaInfo::_internal_set_segment_template_url(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.segment_template_url_.Set(value, GetArena());
}
inline std::string* MediaInfo::_internal_mutable_segment_template_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.segment_template_url_.Mutable( GetArena());
}
inline std::string* MediaInfo::release_segment_template_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.MediaInfo.segment_template_url)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.segment_template_url_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.segment_template_url_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MediaInfo::set_allocated_segment_template_url(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.segment_template_url_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.segment_template_url_.IsDefault()) {
          _impl_.segment_template_url_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:shaka.MediaInfo.segment_template_url)
}

// repeated string hls_characteristics = 20;
inline int MediaInfo::_internal_hls_characteristics_size() const {
  return _internal_hls_characteristics().size();
}
inline int MediaInfo::hls_characteristics_size() const {
  return _internal_hls_characteristics_size();
}
inline void MediaInfo::clear_hls_characteristics() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hls_characteristics_.Clear();
}
inline std::string* MediaInfo::add_hls_characteristics()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_hls_characteristics()->Add();
  // @@protoc_insertion_point(field_add_mutable:shaka.MediaInfo.hls_characteristics)
  return _s;
}
inline const std::string& MediaInfo::hls_characteristics(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.hls_characteristics)
  return _internal_hls_characteristics().Get(index);
}
inline std::string* MediaInfo::mutable_hls_characteristics(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:shaka.MediaInfo.hls_characteristics)
  return _internal_mutable_hls_characteristics()->Mutable(index);
}
inline void MediaInfo::set_hls_characteristics(int index, const std::string& value) {
  _internal_mutable_hls_characteristics()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.hls_characteristics)
}
inline void MediaInfo::set_hls_characteristics(int index, std::string&& value) {
  _internal_mutable_hls_characteristics()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.hls_characteristics)
}
inline void MediaInfo::set_hls_characteristics(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_hls_characteristics()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:shaka.MediaInfo.hls_characteristics)
}
inline void MediaInfo::set_hls_characteristics(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_hls_characteristics()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:shaka.MediaInfo.hls_characteristics)
}
inline void MediaInfo::set_hls_characteristics(int index, absl::string_view value) {
  _internal_mutable_hls_characteristics()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:shaka.MediaInfo.hls_characteristics)
}
inline void MediaInfo::add_hls_characteristics(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_hls_characteristics()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:shaka.MediaInfo.hls_characteristics)
}
inline void MediaInfo::add_hls_characteristics(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_hls_characteristics()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:shaka.MediaInfo.hls_characteristics)
}
inline void MediaInfo::add_hls_characteristics(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_hls_characteristics()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:shaka.MediaInfo.hls_characteristics)
}
inline void MediaInfo::add_hls_characteristics(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_hls_characteristics()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:shaka.MediaInfo.hls_characteristics)
}
inline void MediaInfo::add_hls_characteristics(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_hls_characteristics()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:shaka.MediaInfo.hls_characteristics)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
MediaInfo::hls_characteristics() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:shaka.MediaInfo.hls_characteristics)
  return _internal_hls_characteristics();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
MediaInfo::mutable_hls_characteristics() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:shaka.MediaInfo.hls_characteristics)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_hls_characteristics();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
MediaInfo::_internal_hls_characteristics() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hls_characteristics_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
MediaInfo::_internal_mutable_hls_characteristics() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.hls_characteristics_;
}

// repeated string dash_accessibilities = 21;
inline int MediaInfo::_internal_dash_accessibilities_size() const {
  return _internal_dash_accessibilities().size();
}
inline int MediaInfo::dash_accessibilities_size() const {
  return _internal_dash_accessibilities_size();
}
inline void MediaInfo::clear_dash_accessibilities() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dash_accessibilities_.Clear();
}
inline std::string* MediaInfo::add_dash_accessibilities()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_dash_accessibilities()->Add();
  // @@protoc_insertion_point(field_add_mutable:shaka.MediaInfo.dash_accessibilities)
  return _s;
}
inline const std::string& MediaInfo::dash_accessibilities(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.dash_accessibilities)
  return _internal_dash_accessibilities().Get(index);
}
inline std::string* MediaInfo::mutable_dash_accessibilities(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:shaka.MediaInfo.dash_accessibilities)
  return _internal_mutable_dash_accessibilities()->Mutable(index);
}
inline void MediaInfo::set_dash_accessibilities(int index, const std::string& value) {
  _internal_mutable_dash_accessibilities()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.dash_accessibilities)
}
inline void MediaInfo::set_dash_accessibilities(int index, std::string&& value) {
  _internal_mutable_dash_accessibilities()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.dash_accessibilities)
}
inline void MediaInfo::set_dash_accessibilities(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_dash_accessibilities()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:shaka.MediaInfo.dash_accessibilities)
}
inline void MediaInfo::set_dash_accessibilities(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_dash_accessibilities()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:shaka.MediaInfo.dash_accessibilities)
}
inline void MediaInfo::set_dash_accessibilities(int index, absl::string_view value) {
  _internal_mutable_dash_accessibilities()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:shaka.MediaInfo.dash_accessibilities)
}
inline void MediaInfo::add_dash_accessibilities(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_dash_accessibilities()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:shaka.MediaInfo.dash_accessibilities)
}
inline void MediaInfo::add_dash_accessibilities(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_dash_accessibilities()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:shaka.MediaInfo.dash_accessibilities)
}
inline void MediaInfo::add_dash_accessibilities(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_dash_accessibilities()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:shaka.MediaInfo.dash_accessibilities)
}
inline void MediaInfo::add_dash_accessibilities(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_dash_accessibilities()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:shaka.MediaInfo.dash_accessibilities)
}
inline void MediaInfo::add_dash_accessibilities(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_dash_accessibilities()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:shaka.MediaInfo.dash_accessibilities)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
MediaInfo::dash_accessibilities() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:shaka.MediaInfo.dash_accessibilities)
  return _internal_dash_accessibilities();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
MediaInfo::mutable_dash_accessibilities() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:shaka.MediaInfo.dash_accessibilities)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_dash_accessibilities();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
MediaInfo::_internal_dash_accessibilities() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dash_accessibilities_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
MediaInfo::_internal_mutable_dash_accessibilities() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.dash_accessibilities_;
}

// repeated string dash_roles = 22;
inline int MediaInfo::_internal_dash_roles_size() const {
  return _internal_dash_roles().size();
}
inline int MediaInfo::dash_roles_size() const {
  return _internal_dash_roles_size();
}
inline void MediaInfo::clear_dash_roles() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dash_roles_.Clear();
}
inline std::string* MediaInfo::add_dash_roles()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_dash_roles()->Add();
  // @@protoc_insertion_point(field_add_mutable:shaka.MediaInfo.dash_roles)
  return _s;
}
inline const std::string& MediaInfo::dash_roles(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.dash_roles)
  return _internal_dash_roles().Get(index);
}
inline std::string* MediaInfo::mutable_dash_roles(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:shaka.MediaInfo.dash_roles)
  return _internal_mutable_dash_roles()->Mutable(index);
}
inline void MediaInfo::set_dash_roles(int index, const std::string& value) {
  _internal_mutable_dash_roles()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.dash_roles)
}
inline void MediaInfo::set_dash_roles(int index, std::string&& value) {
  _internal_mutable_dash_roles()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.dash_roles)
}
inline void MediaInfo::set_dash_roles(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_dash_roles()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:shaka.MediaInfo.dash_roles)
}
inline void MediaInfo::set_dash_roles(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_dash_roles()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:shaka.MediaInfo.dash_roles)
}
inline void MediaInfo::set_dash_roles(int index, absl::string_view value) {
  _internal_mutable_dash_roles()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:shaka.MediaInfo.dash_roles)
}
inline void MediaInfo::add_dash_roles(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_dash_roles()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:shaka.MediaInfo.dash_roles)
}
inline void MediaInfo::add_dash_roles(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_dash_roles()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:shaka.MediaInfo.dash_roles)
}
inline void MediaInfo::add_dash_roles(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_dash_roles()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:shaka.MediaInfo.dash_roles)
}
inline void MediaInfo::add_dash_roles(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_dash_roles()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:shaka.MediaInfo.dash_roles)
}
inline void MediaInfo::add_dash_roles(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_dash_roles()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:shaka.MediaInfo.dash_roles)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
MediaInfo::dash_roles() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:shaka.MediaInfo.dash_roles)
  return _internal_dash_roles();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
MediaInfo::mutable_dash_roles() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:shaka.MediaInfo.dash_roles)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_dash_roles();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
MediaInfo::_internal_dash_roles() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dash_roles_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
MediaInfo::_internal_mutable_dash_roles() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.dash_roles_;
}

// optional double availability_time_offset = 24;
inline bool MediaInfo::has_availability_time_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline void MediaInfo::clear_availability_time_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.availability_time_offset_ = 0;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline double MediaInfo::availability_time_offset() const {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.availability_time_offset)
  return _internal_availability_time_offset();
}
inline void MediaInfo::set_availability_time_offset(double value) {
  _internal_set_availability_time_offset(value);
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.availability_time_offset)
}
inline double MediaInfo::_internal_availability_time_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.availability_time_offset_;
}
inline void MediaInfo::_internal_set_availability_time_offset(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.availability_time_offset_ = value;
}

// optional uint64 segment_duration = 25;
inline bool MediaInfo::has_segment_duration() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline void MediaInfo::clear_segment_duration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.segment_duration_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline ::uint64_t MediaInfo::segment_duration() const {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.segment_duration)
  return _internal_segment_duration();
}
inline void MediaInfo::set_segment_duration(::uint64_t value) {
  _internal_set_segment_duration(value);
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.segment_duration)
}
inline ::uint64_t MediaInfo::_internal_segment_duration() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.segment_duration_;
}
inline void MediaInfo::_internal_set_segment_duration(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.segment_duration_ = value;
}

// optional bool forced_subtitle = 26 [default = false];
inline bool MediaInfo::has_forced_subtitle() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline void MediaInfo::clear_forced_subtitle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.forced_subtitle_ = false;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline bool MediaInfo::forced_subtitle() const {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.forced_subtitle)
  return _internal_forced_subtitle();
}
inline void MediaInfo::set_forced_subtitle(bool value) {
  _internal_set_forced_subtitle(value);
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.forced_subtitle)
}
inline bool MediaInfo::_internal_forced_subtitle() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.forced_subtitle_;
}
inline void MediaInfo::_internal_set_forced_subtitle(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.forced_subtitle_ = value;
}

// optional uint32 index = 28;
inline bool MediaInfo::has_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline void MediaInfo::clear_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline ::uint32_t MediaInfo::index() const {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.index)
  return _internal_index();
}
inline void MediaInfo::set_index(::uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.index)
}
inline ::uint32_t MediaInfo::_internal_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.index_;
}
inline void MediaInfo::_internal_set_index(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.index_ = value;
}

// optional string dash_label = 29;
inline bool MediaInfo::has_dash_label() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void MediaInfo::clear_dash_label() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dash_label_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& MediaInfo::dash_label() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.MediaInfo.dash_label)
  return _internal_dash_label();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MediaInfo::set_dash_label(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.dash_label_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.MediaInfo.dash_label)
}
inline std::string* MediaInfo::mutable_dash_label() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_dash_label();
  // @@protoc_insertion_point(field_mutable:shaka.MediaInfo.dash_label)
  return _s;
}
inline const std::string& MediaInfo::_internal_dash_label() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dash_label_.Get();
}
inline void MediaInfo::_internal_set_dash_label(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.dash_label_.Set(value, GetArena());
}
inline std::string* MediaInfo::_internal_mutable_dash_label() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.dash_label_.Mutable( GetArena());
}
inline std::string* MediaInfo::release_dash_label() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.MediaInfo.dash_label)
  if ((_impl_._has_bits_[0] & 0x00000040u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* released = _impl_.dash_label_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dash_label_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MediaInfo::set_allocated_dash_label(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.dash_label_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dash_label_.IsDefault()) {
          _impl_.dash_label_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:shaka.MediaInfo.dash_label)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace shaka


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::shaka::MediaInfo_TextInfo_TextType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::shaka::MediaInfo_TextInfo_TextType>() {
  return ::shaka::MediaInfo_TextInfo_TextType_descriptor();
}
template <>
struct is_proto_enum<::shaka::MediaInfo_ContainerType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::shaka::MediaInfo_ContainerType>() {
  return ::shaka::MediaInfo_ContainerType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_media_5finfo_2eproto_2epb_2eh
