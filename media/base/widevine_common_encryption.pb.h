// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: widevine_common_encryption.proto
// Protobuf C++ Version: 4.25.2

#ifndef GOOGLE_PROTOBUF_INCLUDED_widevine_5fcommon_5fencryption_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_widevine_5fcommon_5fencryption_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025002 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_widevine_5fcommon_5fencryption_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_widevine_5fcommon_5fencryption_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_widevine_5fcommon_5fencryption_2eproto;
namespace shaka {
class CommonEncryptionRequest;
struct CommonEncryptionRequestDefaultTypeInternal;
extern CommonEncryptionRequestDefaultTypeInternal _CommonEncryptionRequest_default_instance_;
class CommonEncryptionRequest_Track;
struct CommonEncryptionRequest_TrackDefaultTypeInternal;
extern CommonEncryptionRequest_TrackDefaultTypeInternal _CommonEncryptionRequest_Track_default_instance_;
class CommonEncryptionResponse;
struct CommonEncryptionResponseDefaultTypeInternal;
extern CommonEncryptionResponseDefaultTypeInternal _CommonEncryptionResponse_default_instance_;
class CommonEncryptionResponse_Drm;
struct CommonEncryptionResponse_DrmDefaultTypeInternal;
extern CommonEncryptionResponse_DrmDefaultTypeInternal _CommonEncryptionResponse_Drm_default_instance_;
class CommonEncryptionResponse_Track;
struct CommonEncryptionResponse_TrackDefaultTypeInternal;
extern CommonEncryptionResponse_TrackDefaultTypeInternal _CommonEncryptionResponse_Track_default_instance_;
class CommonEncryptionResponse_Track_Pssh;
struct CommonEncryptionResponse_Track_PsshDefaultTypeInternal;
extern CommonEncryptionResponse_Track_PsshDefaultTypeInternal _CommonEncryptionResponse_Track_Pssh_default_instance_;
class SignedModularDrmRequest;
struct SignedModularDrmRequestDefaultTypeInternal;
extern SignedModularDrmRequestDefaultTypeInternal _SignedModularDrmRequest_default_instance_;
class SignedModularDrmResponse;
struct SignedModularDrmResponseDefaultTypeInternal;
extern SignedModularDrmResponseDefaultTypeInternal _SignedModularDrmResponse_default_instance_;
}  // namespace shaka
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace shaka {
enum CommonEncryptionRequest_ProtectionScheme : int {
  CommonEncryptionRequest_ProtectionScheme_UNSPECIFIED = 0,
  CommonEncryptionRequest_ProtectionScheme_CENC = 1667591779,
  CommonEncryptionRequest_ProtectionScheme_CBC1 = 1667392305,
  CommonEncryptionRequest_ProtectionScheme_CENS = 1667591795,
  CommonEncryptionRequest_ProtectionScheme_CBCS = 1667392371,
};

bool CommonEncryptionRequest_ProtectionScheme_IsValid(int value);
extern const uint32_t CommonEncryptionRequest_ProtectionScheme_internal_data_[];
constexpr CommonEncryptionRequest_ProtectionScheme CommonEncryptionRequest_ProtectionScheme_ProtectionScheme_MIN = static_cast<CommonEncryptionRequest_ProtectionScheme>(0);
constexpr CommonEncryptionRequest_ProtectionScheme CommonEncryptionRequest_ProtectionScheme_ProtectionScheme_MAX = static_cast<CommonEncryptionRequest_ProtectionScheme>(1667591795);
constexpr int CommonEncryptionRequest_ProtectionScheme_ProtectionScheme_ARRAYSIZE = 1667591795 + 1;
const ::google::protobuf::EnumDescriptor*
CommonEncryptionRequest_ProtectionScheme_descriptor();
template <typename T>
const std::string& CommonEncryptionRequest_ProtectionScheme_Name(T value) {
  static_assert(std::is_same<T, CommonEncryptionRequest_ProtectionScheme>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ProtectionScheme_Name().");
  return ::google::protobuf::internal::NameOfEnum(CommonEncryptionRequest_ProtectionScheme_descriptor(), value);
}
inline bool CommonEncryptionRequest_ProtectionScheme_Parse(absl::string_view name, CommonEncryptionRequest_ProtectionScheme* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommonEncryptionRequest_ProtectionScheme>(
      CommonEncryptionRequest_ProtectionScheme_descriptor(), name, value);
}
enum CommonEncryptionResponse_Status : int {
  CommonEncryptionResponse_Status_OK = 0,
  CommonEncryptionResponse_Status_SIGNATURE_FAILED = 1,
  CommonEncryptionResponse_Status_CONTENT_ID_MISSING = 2,
  CommonEncryptionResponse_Status_POLICY_UNKNOWN = 3,
  CommonEncryptionResponse_Status_TRACK_TYPE_MISSING = 4,
  CommonEncryptionResponse_Status_TRACK_TYPE_UNKNOWN = 5,
  CommonEncryptionResponse_Status_MALFORMED_REQUEST = 6,
  CommonEncryptionResponse_Status_ACCESS_DENIED = 7,
  CommonEncryptionResponse_Status_INTERNAL_ERROR = 8,
  CommonEncryptionResponse_Status_INVALID_WIDEVINE_PSSH = 9,
  CommonEncryptionResponse_Status_TOO_MANY_CONTENT_SPECIFIERS = 10,
  CommonEncryptionResponse_Status_ASSET_NOT_FOUND = 11,
  CommonEncryptionResponse_Status_ASSET_MISSING_KEY = 12,
  CommonEncryptionResponse_Status_CONTENT_ID_MISMATCH = 13,
  CommonEncryptionResponse_Status_KEY_ID_MISMATCH = 14,
  CommonEncryptionResponse_Status_INVALID_GROUP_TRACK_TYPE = 15,
  CommonEncryptionResponse_Status_KEY_ROTATION_WITH_UNSUPPORTED_DRM_TYPE = 16,
  CommonEncryptionResponse_Status_NO_REQUESTED_CRYPTO_PERIODS = 17,
};

bool CommonEncryptionResponse_Status_IsValid(int value);
extern const uint32_t CommonEncryptionResponse_Status_internal_data_[];
constexpr CommonEncryptionResponse_Status CommonEncryptionResponse_Status_Status_MIN = static_cast<CommonEncryptionResponse_Status>(0);
constexpr CommonEncryptionResponse_Status CommonEncryptionResponse_Status_Status_MAX = static_cast<CommonEncryptionResponse_Status>(17);
constexpr int CommonEncryptionResponse_Status_Status_ARRAYSIZE = 17 + 1;
const ::google::protobuf::EnumDescriptor*
CommonEncryptionResponse_Status_descriptor();
template <typename T>
const std::string& CommonEncryptionResponse_Status_Name(T value) {
  static_assert(std::is_same<T, CommonEncryptionResponse_Status>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Status_Name().");
  return CommonEncryptionResponse_Status_Name(static_cast<CommonEncryptionResponse_Status>(value));
}
template <>
inline const std::string& CommonEncryptionResponse_Status_Name(CommonEncryptionResponse_Status value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CommonEncryptionResponse_Status_descriptor,
                                                 0, 17>(
      static_cast<int>(value));
}
inline bool CommonEncryptionResponse_Status_Parse(absl::string_view name, CommonEncryptionResponse_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommonEncryptionResponse_Status>(
      CommonEncryptionResponse_Status_descriptor(), name, value);
}
enum ModularDrmType : int {
  WIDEVINE = 0,
};

bool ModularDrmType_IsValid(int value);
extern const uint32_t ModularDrmType_internal_data_[];
constexpr ModularDrmType ModularDrmType_MIN = static_cast<ModularDrmType>(0);
constexpr ModularDrmType ModularDrmType_MAX = static_cast<ModularDrmType>(0);
constexpr int ModularDrmType_ARRAYSIZE = 0 + 1;
const ::google::protobuf::EnumDescriptor*
ModularDrmType_descriptor();
template <typename T>
const std::string& ModularDrmType_Name(T value) {
  static_assert(std::is_same<T, ModularDrmType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ModularDrmType_Name().");
  return ModularDrmType_Name(static_cast<ModularDrmType>(value));
}
template <>
inline const std::string& ModularDrmType_Name(ModularDrmType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ModularDrmType_descriptor,
                                                 0, 0>(
      static_cast<int>(value));
}
inline bool ModularDrmType_Parse(absl::string_view name, ModularDrmType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ModularDrmType>(
      ModularDrmType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class SignedModularDrmResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:shaka.SignedModularDrmResponse) */ {
 public:
  inline SignedModularDrmResponse() : SignedModularDrmResponse(nullptr) {}
  ~SignedModularDrmResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SignedModularDrmResponse(::google::protobuf::internal::ConstantInitialized);

  inline SignedModularDrmResponse(const SignedModularDrmResponse& from)
      : SignedModularDrmResponse(nullptr, from) {}
  SignedModularDrmResponse(SignedModularDrmResponse&& from) noexcept
    : SignedModularDrmResponse() {
    *this = ::std::move(from);
  }

  inline SignedModularDrmResponse& operator=(const SignedModularDrmResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignedModularDrmResponse& operator=(SignedModularDrmResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignedModularDrmResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignedModularDrmResponse* internal_default_instance() {
    return reinterpret_cast<const SignedModularDrmResponse*>(
               &_SignedModularDrmResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SignedModularDrmResponse& a, SignedModularDrmResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SignedModularDrmResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignedModularDrmResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignedModularDrmResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignedModularDrmResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SignedModularDrmResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SignedModularDrmResponse& from) {
    SignedModularDrmResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SignedModularDrmResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "shaka.SignedModularDrmResponse";
  }
  protected:
  explicit SignedModularDrmResponse(::google::protobuf::Arena* arena);
  SignedModularDrmResponse(::google::protobuf::Arena* arena, const SignedModularDrmResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
    kSignatureFieldNumber = 2,
  };
  // optional bytes response = 1;
  bool has_response() const;
  void clear_response() ;
  const std::string& response() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_response(Arg_&& arg, Args_... args);
  std::string* mutable_response();
  PROTOBUF_NODISCARD std::string* release_response();
  void set_allocated_response(std::string* value);

  private:
  const std::string& _internal_response() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_response(
      const std::string& value);
  std::string* _internal_mutable_response();

  public:
  // optional bytes signature = 2;
  bool has_signature() const;
  void clear_signature() ;
  const std::string& signature() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_signature(Arg_&& arg, Args_... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* value);

  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(
      const std::string& value);
  std::string* _internal_mutable_signature();

  public:
  // @@protoc_insertion_point(class_scope:shaka.SignedModularDrmResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr response_;
    ::google::protobuf::internal::ArenaStringPtr signature_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_widevine_5fcommon_5fencryption_2eproto;
};// -------------------------------------------------------------------

class SignedModularDrmRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:shaka.SignedModularDrmRequest) */ {
 public:
  inline SignedModularDrmRequest() : SignedModularDrmRequest(nullptr) {}
  ~SignedModularDrmRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SignedModularDrmRequest(::google::protobuf::internal::ConstantInitialized);

  inline SignedModularDrmRequest(const SignedModularDrmRequest& from)
      : SignedModularDrmRequest(nullptr, from) {}
  SignedModularDrmRequest(SignedModularDrmRequest&& from) noexcept
    : SignedModularDrmRequest() {
    *this = ::std::move(from);
  }

  inline SignedModularDrmRequest& operator=(const SignedModularDrmRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignedModularDrmRequest& operator=(SignedModularDrmRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignedModularDrmRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignedModularDrmRequest* internal_default_instance() {
    return reinterpret_cast<const SignedModularDrmRequest*>(
               &_SignedModularDrmRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SignedModularDrmRequest& a, SignedModularDrmRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SignedModularDrmRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignedModularDrmRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignedModularDrmRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignedModularDrmRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SignedModularDrmRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SignedModularDrmRequest& from) {
    SignedModularDrmRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SignedModularDrmRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "shaka.SignedModularDrmRequest";
  }
  protected:
  explicit SignedModularDrmRequest(::google::protobuf::Arena* arena);
  SignedModularDrmRequest(::google::protobuf::Arena* arena, const SignedModularDrmRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestFieldNumber = 1,
    kSignatureFieldNumber = 2,
    kSignerFieldNumber = 3,
  };
  // optional bytes request = 1;
  bool has_request() const;
  void clear_request() ;
  const std::string& request() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_request(Arg_&& arg, Args_... args);
  std::string* mutable_request();
  PROTOBUF_NODISCARD std::string* release_request();
  void set_allocated_request(std::string* value);

  private:
  const std::string& _internal_request() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request(
      const std::string& value);
  std::string* _internal_mutable_request();

  public:
  // optional bytes signature = 2;
  bool has_signature() const;
  void clear_signature() ;
  const std::string& signature() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_signature(Arg_&& arg, Args_... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* value);

  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(
      const std::string& value);
  std::string* _internal_mutable_signature();

  public:
  // optional string signer = 3;
  bool has_signer() const;
  void clear_signer() ;
  const std::string& signer() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_signer(Arg_&& arg, Args_... args);
  std::string* mutable_signer();
  PROTOBUF_NODISCARD std::string* release_signer();
  void set_allocated_signer(std::string* value);

  private:
  const std::string& _internal_signer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signer(
      const std::string& value);
  std::string* _internal_mutable_signer();

  public:
  // @@protoc_insertion_point(class_scope:shaka.SignedModularDrmRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      44, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr request_;
    ::google::protobuf::internal::ArenaStringPtr signature_;
    ::google::protobuf::internal::ArenaStringPtr signer_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_widevine_5fcommon_5fencryption_2eproto;
};// -------------------------------------------------------------------

class CommonEncryptionResponse_Track_Pssh final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:shaka.CommonEncryptionResponse.Track.Pssh) */ {
 public:
  inline CommonEncryptionResponse_Track_Pssh() : CommonEncryptionResponse_Track_Pssh(nullptr) {}
  ~CommonEncryptionResponse_Track_Pssh() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommonEncryptionResponse_Track_Pssh(::google::protobuf::internal::ConstantInitialized);

  inline CommonEncryptionResponse_Track_Pssh(const CommonEncryptionResponse_Track_Pssh& from)
      : CommonEncryptionResponse_Track_Pssh(nullptr, from) {}
  CommonEncryptionResponse_Track_Pssh(CommonEncryptionResponse_Track_Pssh&& from) noexcept
    : CommonEncryptionResponse_Track_Pssh() {
    *this = ::std::move(from);
  }

  inline CommonEncryptionResponse_Track_Pssh& operator=(const CommonEncryptionResponse_Track_Pssh& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommonEncryptionResponse_Track_Pssh& operator=(CommonEncryptionResponse_Track_Pssh&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommonEncryptionResponse_Track_Pssh& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommonEncryptionResponse_Track_Pssh* internal_default_instance() {
    return reinterpret_cast<const CommonEncryptionResponse_Track_Pssh*>(
               &_CommonEncryptionResponse_Track_Pssh_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CommonEncryptionResponse_Track_Pssh& a, CommonEncryptionResponse_Track_Pssh& b) {
    a.Swap(&b);
  }
  inline void Swap(CommonEncryptionResponse_Track_Pssh* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommonEncryptionResponse_Track_Pssh* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommonEncryptionResponse_Track_Pssh* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommonEncryptionResponse_Track_Pssh>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CommonEncryptionResponse_Track_Pssh& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CommonEncryptionResponse_Track_Pssh& from) {
    CommonEncryptionResponse_Track_Pssh::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommonEncryptionResponse_Track_Pssh* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "shaka.CommonEncryptionResponse.Track.Pssh";
  }
  protected:
  explicit CommonEncryptionResponse_Track_Pssh(::google::protobuf::Arena* arena);
  CommonEncryptionResponse_Track_Pssh(::google::protobuf::Arena* arena, const CommonEncryptionResponse_Track_Pssh& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kBoxesFieldNumber = 3,
    kDrmTypeFieldNumber = 1,
  };
  // optional bytes data = 2;
  bool has_data() const;
  void clear_data() ;
  const std::string& data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* value);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // optional bytes boxes = 3;
  bool has_boxes() const;
  void clear_boxes() ;
  const std::string& boxes() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_boxes(Arg_&& arg, Args_... args);
  std::string* mutable_boxes();
  PROTOBUF_NODISCARD std::string* release_boxes();
  void set_allocated_boxes(std::string* value);

  private:
  const std::string& _internal_boxes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_boxes(
      const std::string& value);
  std::string* _internal_mutable_boxes();

  public:
  // optional .shaka.ModularDrmType drm_type = 1;
  bool has_drm_type() const;
  void clear_drm_type() ;
  ::shaka::ModularDrmType drm_type() const;
  void set_drm_type(::shaka::ModularDrmType value);

  private:
  ::shaka::ModularDrmType _internal_drm_type() const;
  void _internal_set_drm_type(::shaka::ModularDrmType value);

  public:
  // @@protoc_insertion_point(class_scope:shaka.CommonEncryptionResponse.Track.Pssh)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr data_;
    ::google::protobuf::internal::ArenaStringPtr boxes_;
    int drm_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_widevine_5fcommon_5fencryption_2eproto;
};// -------------------------------------------------------------------

class CommonEncryptionResponse_Drm final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:shaka.CommonEncryptionResponse.Drm) */ {
 public:
  inline CommonEncryptionResponse_Drm() : CommonEncryptionResponse_Drm(nullptr) {}
  ~CommonEncryptionResponse_Drm() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommonEncryptionResponse_Drm(::google::protobuf::internal::ConstantInitialized);

  inline CommonEncryptionResponse_Drm(const CommonEncryptionResponse_Drm& from)
      : CommonEncryptionResponse_Drm(nullptr, from) {}
  CommonEncryptionResponse_Drm(CommonEncryptionResponse_Drm&& from) noexcept
    : CommonEncryptionResponse_Drm() {
    *this = ::std::move(from);
  }

  inline CommonEncryptionResponse_Drm& operator=(const CommonEncryptionResponse_Drm& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommonEncryptionResponse_Drm& operator=(CommonEncryptionResponse_Drm&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommonEncryptionResponse_Drm& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommonEncryptionResponse_Drm* internal_default_instance() {
    return reinterpret_cast<const CommonEncryptionResponse_Drm*>(
               &_CommonEncryptionResponse_Drm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CommonEncryptionResponse_Drm& a, CommonEncryptionResponse_Drm& b) {
    a.Swap(&b);
  }
  inline void Swap(CommonEncryptionResponse_Drm* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommonEncryptionResponse_Drm* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommonEncryptionResponse_Drm* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommonEncryptionResponse_Drm>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CommonEncryptionResponse_Drm& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CommonEncryptionResponse_Drm& from) {
    CommonEncryptionResponse_Drm::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommonEncryptionResponse_Drm* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "shaka.CommonEncryptionResponse.Drm";
  }
  protected:
  explicit CommonEncryptionResponse_Drm(::google::protobuf::Arena* arena);
  CommonEncryptionResponse_Drm(::google::protobuf::Arena* arena, const CommonEncryptionResponse_Drm& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSystemIdFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // optional string system_id = 2;
  bool has_system_id() const;
  void clear_system_id() ;
  const std::string& system_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_system_id(Arg_&& arg, Args_... args);
  std::string* mutable_system_id();
  PROTOBUF_NODISCARD std::string* release_system_id();
  void set_allocated_system_id(std::string* value);

  private:
  const std::string& _internal_system_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_system_id(
      const std::string& value);
  std::string* _internal_mutable_system_id();

  public:
  // optional .shaka.ModularDrmType type = 1;
  bool has_type() const;
  void clear_type() ;
  ::shaka::ModularDrmType type() const;
  void set_type(::shaka::ModularDrmType value);

  private:
  ::shaka::ModularDrmType _internal_type() const;
  void _internal_set_type(::shaka::ModularDrmType value);

  public:
  // @@protoc_insertion_point(class_scope:shaka.CommonEncryptionResponse.Drm)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      52, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr system_id_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_widevine_5fcommon_5fencryption_2eproto;
};// -------------------------------------------------------------------

class CommonEncryptionRequest_Track final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:shaka.CommonEncryptionRequest.Track) */ {
 public:
  inline CommonEncryptionRequest_Track() : CommonEncryptionRequest_Track(nullptr) {}
  ~CommonEncryptionRequest_Track() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommonEncryptionRequest_Track(::google::protobuf::internal::ConstantInitialized);

  inline CommonEncryptionRequest_Track(const CommonEncryptionRequest_Track& from)
      : CommonEncryptionRequest_Track(nullptr, from) {}
  CommonEncryptionRequest_Track(CommonEncryptionRequest_Track&& from) noexcept
    : CommonEncryptionRequest_Track() {
    *this = ::std::move(from);
  }

  inline CommonEncryptionRequest_Track& operator=(const CommonEncryptionRequest_Track& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommonEncryptionRequest_Track& operator=(CommonEncryptionRequest_Track&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommonEncryptionRequest_Track& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommonEncryptionRequest_Track* internal_default_instance() {
    return reinterpret_cast<const CommonEncryptionRequest_Track*>(
               &_CommonEncryptionRequest_Track_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CommonEncryptionRequest_Track& a, CommonEncryptionRequest_Track& b) {
    a.Swap(&b);
  }
  inline void Swap(CommonEncryptionRequest_Track* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommonEncryptionRequest_Track* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommonEncryptionRequest_Track* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommonEncryptionRequest_Track>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CommonEncryptionRequest_Track& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CommonEncryptionRequest_Track& from) {
    CommonEncryptionRequest_Track::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommonEncryptionRequest_Track* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "shaka.CommonEncryptionRequest.Track";
  }
  protected:
  explicit CommonEncryptionRequest_Track(::google::protobuf::Arena* arena);
  CommonEncryptionRequest_Track(::google::protobuf::Arena* arena, const CommonEncryptionRequest_Track& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // optional string type = 1;
  bool has_type() const;
  void clear_type() ;
  const std::string& type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* value);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // @@protoc_insertion_point(class_scope:shaka.CommonEncryptionRequest.Track)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      48, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_widevine_5fcommon_5fencryption_2eproto;
};// -------------------------------------------------------------------

class CommonEncryptionResponse_Track final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:shaka.CommonEncryptionResponse.Track) */ {
 public:
  inline CommonEncryptionResponse_Track() : CommonEncryptionResponse_Track(nullptr) {}
  ~CommonEncryptionResponse_Track() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommonEncryptionResponse_Track(::google::protobuf::internal::ConstantInitialized);

  inline CommonEncryptionResponse_Track(const CommonEncryptionResponse_Track& from)
      : CommonEncryptionResponse_Track(nullptr, from) {}
  CommonEncryptionResponse_Track(CommonEncryptionResponse_Track&& from) noexcept
    : CommonEncryptionResponse_Track() {
    *this = ::std::move(from);
  }

  inline CommonEncryptionResponse_Track& operator=(const CommonEncryptionResponse_Track& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommonEncryptionResponse_Track& operator=(CommonEncryptionResponse_Track&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommonEncryptionResponse_Track& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommonEncryptionResponse_Track* internal_default_instance() {
    return reinterpret_cast<const CommonEncryptionResponse_Track*>(
               &_CommonEncryptionResponse_Track_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CommonEncryptionResponse_Track& a, CommonEncryptionResponse_Track& b) {
    a.Swap(&b);
  }
  inline void Swap(CommonEncryptionResponse_Track* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommonEncryptionResponse_Track* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommonEncryptionResponse_Track* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommonEncryptionResponse_Track>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CommonEncryptionResponse_Track& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CommonEncryptionResponse_Track& from) {
    CommonEncryptionResponse_Track::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommonEncryptionResponse_Track* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "shaka.CommonEncryptionResponse.Track";
  }
  protected:
  explicit CommonEncryptionResponse_Track(::google::protobuf::Arena* arena);
  CommonEncryptionResponse_Track(::google::protobuf::Arena* arena, const CommonEncryptionResponse_Track& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Pssh = CommonEncryptionResponse_Track_Pssh;

  // accessors -------------------------------------------------------

  enum : int {
    kPsshFieldNumber = 5,
    kTypeFieldNumber = 1,
    kKeyIdFieldNumber = 2,
    kKeyFieldNumber = 3,
    kIvFieldNumber = 4,
    kCryptoPeriodIndexFieldNumber = 6,
  };
  // repeated .shaka.CommonEncryptionResponse.Track.Pssh pssh = 5;
  int pssh_size() const;
  private:
  int _internal_pssh_size() const;

  public:
  void clear_pssh() ;
  ::shaka::CommonEncryptionResponse_Track_Pssh* mutable_pssh(int index);
  ::google::protobuf::RepeatedPtrField< ::shaka::CommonEncryptionResponse_Track_Pssh >*
      mutable_pssh();
  private:
  const ::google::protobuf::RepeatedPtrField<::shaka::CommonEncryptionResponse_Track_Pssh>& _internal_pssh() const;
  ::google::protobuf::RepeatedPtrField<::shaka::CommonEncryptionResponse_Track_Pssh>* _internal_mutable_pssh();
  public:
  const ::shaka::CommonEncryptionResponse_Track_Pssh& pssh(int index) const;
  ::shaka::CommonEncryptionResponse_Track_Pssh* add_pssh();
  const ::google::protobuf::RepeatedPtrField< ::shaka::CommonEncryptionResponse_Track_Pssh >&
      pssh() const;
  // optional string type = 1;
  bool has_type() const;
  void clear_type() ;
  const std::string& type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* value);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // optional bytes key_id = 2;
  bool has_key_id() const;
  void clear_key_id() ;
  const std::string& key_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key_id(Arg_&& arg, Args_... args);
  std::string* mutable_key_id();
  PROTOBUF_NODISCARD std::string* release_key_id();
  void set_allocated_key_id(std::string* value);

  private:
  const std::string& _internal_key_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key_id(
      const std::string& value);
  std::string* _internal_mutable_key_id();

  public:
  // optional bytes key = 3;
  bool has_key() const;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // optional bytes iv = 4;
  bool has_iv() const;
  void clear_iv() ;
  const std::string& iv() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_iv(Arg_&& arg, Args_... args);
  std::string* mutable_iv();
  PROTOBUF_NODISCARD std::string* release_iv();
  void set_allocated_iv(std::string* value);

  private:
  const std::string& _internal_iv() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_iv(
      const std::string& value);
  std::string* _internal_mutable_iv();

  public:
  // optional uint32 crypto_period_index = 6;
  bool has_crypto_period_index() const;
  void clear_crypto_period_index() ;
  ::uint32_t crypto_period_index() const;
  void set_crypto_period_index(::uint32_t value);

  private:
  ::uint32_t _internal_crypto_period_index() const;
  void _internal_set_crypto_period_index(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:shaka.CommonEncryptionResponse.Track)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      49, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::shaka::CommonEncryptionResponse_Track_Pssh > pssh_;
    ::google::protobuf::internal::ArenaStringPtr type_;
    ::google::protobuf::internal::ArenaStringPtr key_id_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::google::protobuf::internal::ArenaStringPtr iv_;
    ::uint32_t crypto_period_index_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_widevine_5fcommon_5fencryption_2eproto;
};// -------------------------------------------------------------------

class CommonEncryptionRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:shaka.CommonEncryptionRequest) */ {
 public:
  inline CommonEncryptionRequest() : CommonEncryptionRequest(nullptr) {}
  ~CommonEncryptionRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommonEncryptionRequest(::google::protobuf::internal::ConstantInitialized);

  inline CommonEncryptionRequest(const CommonEncryptionRequest& from)
      : CommonEncryptionRequest(nullptr, from) {}
  CommonEncryptionRequest(CommonEncryptionRequest&& from) noexcept
    : CommonEncryptionRequest() {
    *this = ::std::move(from);
  }

  inline CommonEncryptionRequest& operator=(const CommonEncryptionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommonEncryptionRequest& operator=(CommonEncryptionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommonEncryptionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommonEncryptionRequest* internal_default_instance() {
    return reinterpret_cast<const CommonEncryptionRequest*>(
               &_CommonEncryptionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CommonEncryptionRequest& a, CommonEncryptionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CommonEncryptionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommonEncryptionRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommonEncryptionRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommonEncryptionRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CommonEncryptionRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CommonEncryptionRequest& from) {
    CommonEncryptionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommonEncryptionRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "shaka.CommonEncryptionRequest";
  }
  protected:
  explicit CommonEncryptionRequest(::google::protobuf::Arena* arena);
  CommonEncryptionRequest(::google::protobuf::Arena* arena, const CommonEncryptionRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Track = CommonEncryptionRequest_Track;

  using ProtectionScheme = CommonEncryptionRequest_ProtectionScheme;
  static constexpr ProtectionScheme UNSPECIFIED = CommonEncryptionRequest_ProtectionScheme_UNSPECIFIED;
  static constexpr ProtectionScheme CENC = CommonEncryptionRequest_ProtectionScheme_CENC;
  static constexpr ProtectionScheme CBC1 = CommonEncryptionRequest_ProtectionScheme_CBC1;
  static constexpr ProtectionScheme CENS = CommonEncryptionRequest_ProtectionScheme_CENS;
  static constexpr ProtectionScheme CBCS = CommonEncryptionRequest_ProtectionScheme_CBCS;
  static inline bool ProtectionScheme_IsValid(int value) {
    return CommonEncryptionRequest_ProtectionScheme_IsValid(value);
  }
  static constexpr ProtectionScheme ProtectionScheme_MIN = CommonEncryptionRequest_ProtectionScheme_ProtectionScheme_MIN;
  static constexpr ProtectionScheme ProtectionScheme_MAX = CommonEncryptionRequest_ProtectionScheme_ProtectionScheme_MAX;
  static constexpr int ProtectionScheme_ARRAYSIZE = CommonEncryptionRequest_ProtectionScheme_ProtectionScheme_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ProtectionScheme_descriptor() {
    return CommonEncryptionRequest_ProtectionScheme_descriptor();
  }
  template <typename T>
  static inline const std::string& ProtectionScheme_Name(T value) {
    return CommonEncryptionRequest_ProtectionScheme_Name(value);
  }
  static inline bool ProtectionScheme_Parse(absl::string_view name, ProtectionScheme* value) {
    return CommonEncryptionRequest_ProtectionScheme_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTracksFieldNumber = 3,
    kDrmTypesFieldNumber = 4,
    kContentIdFieldNumber = 1,
    kPolicyFieldNumber = 2,
    kPsshDataFieldNumber = 10,
    kGroupIdFieldNumber = 12,
    kVideoFeatureFieldNumber = 19,
    kFirstCryptoPeriodIndexFieldNumber = 8,
    kAssetIdFieldNumber = 11,
    kCryptoPeriodSecondsFieldNumber = 13,
    kProtectionSchemeFieldNumber = 14,
    kEnableEntitlementLicenseFieldNumber = 16,
    kCryptoPeriodCountFieldNumber = 9,
  };
  // repeated .shaka.CommonEncryptionRequest.Track tracks = 3;
  int tracks_size() const;
  private:
  int _internal_tracks_size() const;

  public:
  void clear_tracks() ;
  ::shaka::CommonEncryptionRequest_Track* mutable_tracks(int index);
  ::google::protobuf::RepeatedPtrField< ::shaka::CommonEncryptionRequest_Track >*
      mutable_tracks();
  private:
  const ::google::protobuf::RepeatedPtrField<::shaka::CommonEncryptionRequest_Track>& _internal_tracks() const;
  ::google::protobuf::RepeatedPtrField<::shaka::CommonEncryptionRequest_Track>* _internal_mutable_tracks();
  public:
  const ::shaka::CommonEncryptionRequest_Track& tracks(int index) const;
  ::shaka::CommonEncryptionRequest_Track* add_tracks();
  const ::google::protobuf::RepeatedPtrField< ::shaka::CommonEncryptionRequest_Track >&
      tracks() const;
  // repeated .shaka.ModularDrmType drm_types = 4;
  int drm_types_size() const;
  private:
  int _internal_drm_types_size() const;

  public:
  void clear_drm_types() ;
  public:
  ::shaka::ModularDrmType drm_types(int index) const;
  void set_drm_types(int index, ::shaka::ModularDrmType value);
  void add_drm_types(::shaka::ModularDrmType value);
  const ::google::protobuf::RepeatedField<int>& drm_types() const;
  ::google::protobuf::RepeatedField<int>* mutable_drm_types();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_drm_types() const;
  ::google::protobuf::RepeatedField<int>* _internal_mutable_drm_types();

  public:
  // optional bytes content_id = 1;
  bool has_content_id() const;
  void clear_content_id() ;
  const std::string& content_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_content_id(Arg_&& arg, Args_... args);
  std::string* mutable_content_id();
  PROTOBUF_NODISCARD std::string* release_content_id();
  void set_allocated_content_id(std::string* value);

  private:
  const std::string& _internal_content_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content_id(
      const std::string& value);
  std::string* _internal_mutable_content_id();

  public:
  // optional string policy = 2;
  bool has_policy() const;
  void clear_policy() ;
  const std::string& policy() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_policy(Arg_&& arg, Args_... args);
  std::string* mutable_policy();
  PROTOBUF_NODISCARD std::string* release_policy();
  void set_allocated_policy(std::string* value);

  private:
  const std::string& _internal_policy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_policy(
      const std::string& value);
  std::string* _internal_mutable_policy();

  public:
  // optional bytes pssh_data = 10;
  bool has_pssh_data() const;
  void clear_pssh_data() ;
  const std::string& pssh_data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pssh_data(Arg_&& arg, Args_... args);
  std::string* mutable_pssh_data();
  PROTOBUF_NODISCARD std::string* release_pssh_data();
  void set_allocated_pssh_data(std::string* value);

  private:
  const std::string& _internal_pssh_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pssh_data(
      const std::string& value);
  std::string* _internal_mutable_pssh_data();

  public:
  // optional bytes group_id = 12;
  bool has_group_id() const;
  void clear_group_id() ;
  const std::string& group_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_group_id(Arg_&& arg, Args_... args);
  std::string* mutable_group_id();
  PROTOBUF_NODISCARD std::string* release_group_id();
  void set_allocated_group_id(std::string* value);

  private:
  const std::string& _internal_group_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group_id(
      const std::string& value);
  std::string* _internal_mutable_group_id();

  public:
  // optional string video_feature = 19;
  bool has_video_feature() const;
  void clear_video_feature() ;
  const std::string& video_feature() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_video_feature(Arg_&& arg, Args_... args);
  std::string* mutable_video_feature();
  PROTOBUF_NODISCARD std::string* release_video_feature();
  void set_allocated_video_feature(std::string* value);

  private:
  const std::string& _internal_video_feature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_video_feature(
      const std::string& value);
  std::string* _internal_mutable_video_feature();

  public:
  // optional uint32 first_crypto_period_index = 8;
  bool has_first_crypto_period_index() const;
  void clear_first_crypto_period_index() ;
  ::uint32_t first_crypto_period_index() const;
  void set_first_crypto_period_index(::uint32_t value);

  private:
  ::uint32_t _internal_first_crypto_period_index() const;
  void _internal_set_first_crypto_period_index(::uint32_t value);

  public:
  // optional uint32 asset_id = 11;
  bool has_asset_id() const;
  void clear_asset_id() ;
  ::uint32_t asset_id() const;
  void set_asset_id(::uint32_t value);

  private:
  ::uint32_t _internal_asset_id() const;
  void _internal_set_asset_id(::uint32_t value);

  public:
  // optional uint32 crypto_period_seconds = 13;
  bool has_crypto_period_seconds() const;
  void clear_crypto_period_seconds() ;
  ::uint32_t crypto_period_seconds() const;
  void set_crypto_period_seconds(::uint32_t value);

  private:
  ::uint32_t _internal_crypto_period_seconds() const;
  void _internal_set_crypto_period_seconds(::uint32_t value);

  public:
  // optional .shaka.CommonEncryptionRequest.ProtectionScheme protection_scheme = 14;
  bool has_protection_scheme() const;
  void clear_protection_scheme() ;
  ::shaka::CommonEncryptionRequest_ProtectionScheme protection_scheme() const;
  void set_protection_scheme(::shaka::CommonEncryptionRequest_ProtectionScheme value);

  private:
  ::shaka::CommonEncryptionRequest_ProtectionScheme _internal_protection_scheme() const;
  void _internal_set_protection_scheme(::shaka::CommonEncryptionRequest_ProtectionScheme value);

  public:
  // optional bool enable_entitlement_license = 16;
  bool has_enable_entitlement_license() const;
  void clear_enable_entitlement_license() ;
  bool enable_entitlement_license() const;
  void set_enable_entitlement_license(bool value);

  private:
  bool _internal_enable_entitlement_license() const;
  void _internal_set_enable_entitlement_license(bool value);

  public:
  // optional uint32 crypto_period_count = 9 [default = 1];
  bool has_crypto_period_count() const;
  void clear_crypto_period_count() ;
  ::uint32_t crypto_period_count() const;
  void set_crypto_period_count(::uint32_t value);

  private:
  ::uint32_t _internal_crypto_period_count() const;
  void _internal_set_crypto_period_count(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:shaka.CommonEncryptionRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 13, 3,
      65, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::shaka::CommonEncryptionRequest_Track > tracks_;
    ::google::protobuf::RepeatedField<int> drm_types_;
    ::google::protobuf::internal::ArenaStringPtr content_id_;
    ::google::protobuf::internal::ArenaStringPtr policy_;
    ::google::protobuf::internal::ArenaStringPtr pssh_data_;
    ::google::protobuf::internal::ArenaStringPtr group_id_;
    ::google::protobuf::internal::ArenaStringPtr video_feature_;
    ::uint32_t first_crypto_period_index_;
    ::uint32_t asset_id_;
    ::uint32_t crypto_period_seconds_;
    int protection_scheme_;
    bool enable_entitlement_license_;
    ::uint32_t crypto_period_count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_widevine_5fcommon_5fencryption_2eproto;
};// -------------------------------------------------------------------

class CommonEncryptionResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:shaka.CommonEncryptionResponse) */ {
 public:
  inline CommonEncryptionResponse() : CommonEncryptionResponse(nullptr) {}
  ~CommonEncryptionResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommonEncryptionResponse(::google::protobuf::internal::ConstantInitialized);

  inline CommonEncryptionResponse(const CommonEncryptionResponse& from)
      : CommonEncryptionResponse(nullptr, from) {}
  CommonEncryptionResponse(CommonEncryptionResponse&& from) noexcept
    : CommonEncryptionResponse() {
    *this = ::std::move(from);
  }

  inline CommonEncryptionResponse& operator=(const CommonEncryptionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommonEncryptionResponse& operator=(CommonEncryptionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommonEncryptionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommonEncryptionResponse* internal_default_instance() {
    return reinterpret_cast<const CommonEncryptionResponse*>(
               &_CommonEncryptionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CommonEncryptionResponse& a, CommonEncryptionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommonEncryptionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommonEncryptionResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommonEncryptionResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommonEncryptionResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CommonEncryptionResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CommonEncryptionResponse& from) {
    CommonEncryptionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommonEncryptionResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "shaka.CommonEncryptionResponse";
  }
  protected:
  explicit CommonEncryptionResponse(::google::protobuf::Arena* arena);
  CommonEncryptionResponse(::google::protobuf::Arena* arena, const CommonEncryptionResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Drm = CommonEncryptionResponse_Drm;
  using Track = CommonEncryptionResponse_Track;

  using Status = CommonEncryptionResponse_Status;
  static constexpr Status OK = CommonEncryptionResponse_Status_OK;
  static constexpr Status SIGNATURE_FAILED = CommonEncryptionResponse_Status_SIGNATURE_FAILED;
  static constexpr Status CONTENT_ID_MISSING = CommonEncryptionResponse_Status_CONTENT_ID_MISSING;
  static constexpr Status POLICY_UNKNOWN = CommonEncryptionResponse_Status_POLICY_UNKNOWN;
  static constexpr Status TRACK_TYPE_MISSING = CommonEncryptionResponse_Status_TRACK_TYPE_MISSING;
  static constexpr Status TRACK_TYPE_UNKNOWN = CommonEncryptionResponse_Status_TRACK_TYPE_UNKNOWN;
  static constexpr Status MALFORMED_REQUEST = CommonEncryptionResponse_Status_MALFORMED_REQUEST;
  static constexpr Status ACCESS_DENIED = CommonEncryptionResponse_Status_ACCESS_DENIED;
  static constexpr Status INTERNAL_ERROR = CommonEncryptionResponse_Status_INTERNAL_ERROR;
  static constexpr Status INVALID_WIDEVINE_PSSH = CommonEncryptionResponse_Status_INVALID_WIDEVINE_PSSH;
  static constexpr Status TOO_MANY_CONTENT_SPECIFIERS = CommonEncryptionResponse_Status_TOO_MANY_CONTENT_SPECIFIERS;
  static constexpr Status ASSET_NOT_FOUND = CommonEncryptionResponse_Status_ASSET_NOT_FOUND;
  static constexpr Status ASSET_MISSING_KEY = CommonEncryptionResponse_Status_ASSET_MISSING_KEY;
  static constexpr Status CONTENT_ID_MISMATCH = CommonEncryptionResponse_Status_CONTENT_ID_MISMATCH;
  static constexpr Status KEY_ID_MISMATCH = CommonEncryptionResponse_Status_KEY_ID_MISMATCH;
  static constexpr Status INVALID_GROUP_TRACK_TYPE = CommonEncryptionResponse_Status_INVALID_GROUP_TRACK_TYPE;
  static constexpr Status KEY_ROTATION_WITH_UNSUPPORTED_DRM_TYPE = CommonEncryptionResponse_Status_KEY_ROTATION_WITH_UNSUPPORTED_DRM_TYPE;
  static constexpr Status NO_REQUESTED_CRYPTO_PERIODS = CommonEncryptionResponse_Status_NO_REQUESTED_CRYPTO_PERIODS;
  static inline bool Status_IsValid(int value) {
    return CommonEncryptionResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN = CommonEncryptionResponse_Status_Status_MIN;
  static constexpr Status Status_MAX = CommonEncryptionResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE = CommonEncryptionResponse_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Status_descriptor() {
    return CommonEncryptionResponse_Status_descriptor();
  }
  template <typename T>
  static inline const std::string& Status_Name(T value) {
    return CommonEncryptionResponse_Status_Name(value);
  }
  static inline bool Status_Parse(absl::string_view name, Status* value) {
    return CommonEncryptionResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDrmFieldNumber = 3,
    kTracksFieldNumber = 4,
    kContentIdFieldNumber = 6,
    kStatusFieldNumber = 1,
  };
  // repeated .shaka.CommonEncryptionResponse.Drm drm = 3;
  int drm_size() const;
  private:
  int _internal_drm_size() const;

  public:
  void clear_drm() ;
  ::shaka::CommonEncryptionResponse_Drm* mutable_drm(int index);
  ::google::protobuf::RepeatedPtrField< ::shaka::CommonEncryptionResponse_Drm >*
      mutable_drm();
  private:
  const ::google::protobuf::RepeatedPtrField<::shaka::CommonEncryptionResponse_Drm>& _internal_drm() const;
  ::google::protobuf::RepeatedPtrField<::shaka::CommonEncryptionResponse_Drm>* _internal_mutable_drm();
  public:
  const ::shaka::CommonEncryptionResponse_Drm& drm(int index) const;
  ::shaka::CommonEncryptionResponse_Drm* add_drm();
  const ::google::protobuf::RepeatedPtrField< ::shaka::CommonEncryptionResponse_Drm >&
      drm() const;
  // repeated .shaka.CommonEncryptionResponse.Track tracks = 4;
  int tracks_size() const;
  private:
  int _internal_tracks_size() const;

  public:
  void clear_tracks() ;
  ::shaka::CommonEncryptionResponse_Track* mutable_tracks(int index);
  ::google::protobuf::RepeatedPtrField< ::shaka::CommonEncryptionResponse_Track >*
      mutable_tracks();
  private:
  const ::google::protobuf::RepeatedPtrField<::shaka::CommonEncryptionResponse_Track>& _internal_tracks() const;
  ::google::protobuf::RepeatedPtrField<::shaka::CommonEncryptionResponse_Track>* _internal_mutable_tracks();
  public:
  const ::shaka::CommonEncryptionResponse_Track& tracks(int index) const;
  ::shaka::CommonEncryptionResponse_Track* add_tracks();
  const ::google::protobuf::RepeatedPtrField< ::shaka::CommonEncryptionResponse_Track >&
      tracks() const;
  // optional bytes content_id = 6;
  bool has_content_id() const;
  void clear_content_id() ;
  const std::string& content_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_content_id(Arg_&& arg, Args_... args);
  std::string* mutable_content_id();
  PROTOBUF_NODISCARD std::string* release_content_id();
  void set_allocated_content_id(std::string* value);

  private:
  const std::string& _internal_content_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content_id(
      const std::string& value);
  std::string* _internal_mutable_content_id();

  public:
  // optional .shaka.CommonEncryptionResponse.Status status = 1;
  bool has_status() const;
  void clear_status() ;
  ::shaka::CommonEncryptionResponse_Status status() const;
  void set_status(::shaka::CommonEncryptionResponse_Status value);

  private:
  ::shaka::CommonEncryptionResponse_Status _internal_status() const;
  void _internal_set_status(::shaka::CommonEncryptionResponse_Status value);

  public:
  // @@protoc_insertion_point(class_scope:shaka.CommonEncryptionResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::shaka::CommonEncryptionResponse_Drm > drm_;
    ::google::protobuf::RepeatedPtrField< ::shaka::CommonEncryptionResponse_Track > tracks_;
    ::google::protobuf::internal::ArenaStringPtr content_id_;
    int status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_widevine_5fcommon_5fencryption_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// CommonEncryptionRequest_Track

// optional string type = 1;
inline bool CommonEncryptionRequest_Track::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommonEncryptionRequest_Track::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommonEncryptionRequest_Track::type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.CommonEncryptionRequest.Track.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommonEncryptionRequest_Track::set_type(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.CommonEncryptionRequest.Track.type)
}
inline std::string* CommonEncryptionRequest_Track::mutable_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:shaka.CommonEncryptionRequest.Track.type)
  return _s;
}
inline const std::string& CommonEncryptionRequest_Track::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_.Get();
}
inline void CommonEncryptionRequest_Track::_internal_set_type(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_.Set(value, GetArena());
}
inline std::string* CommonEncryptionRequest_Track::_internal_mutable_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.type_.Mutable( GetArena());
}
inline std::string* CommonEncryptionRequest_Track::release_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.CommonEncryptionRequest.Track.type)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.type_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.type_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommonEncryptionRequest_Track::set_allocated_type(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.type_.IsDefault()) {
          _impl_.type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:shaka.CommonEncryptionRequest.Track.type)
}

// -------------------------------------------------------------------

// CommonEncryptionRequest

// optional bytes content_id = 1;
inline bool CommonEncryptionRequest::has_content_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommonEncryptionRequest::clear_content_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.content_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommonEncryptionRequest::content_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.CommonEncryptionRequest.content_id)
  return _internal_content_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommonEncryptionRequest::set_content_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.content_id_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.CommonEncryptionRequest.content_id)
}
inline std::string* CommonEncryptionRequest::mutable_content_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_content_id();
  // @@protoc_insertion_point(field_mutable:shaka.CommonEncryptionRequest.content_id)
  return _s;
}
inline const std::string& CommonEncryptionRequest::_internal_content_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.content_id_.Get();
}
inline void CommonEncryptionRequest::_internal_set_content_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.content_id_.Set(value, GetArena());
}
inline std::string* CommonEncryptionRequest::_internal_mutable_content_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.content_id_.Mutable( GetArena());
}
inline std::string* CommonEncryptionRequest::release_content_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.CommonEncryptionRequest.content_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.content_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.content_id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommonEncryptionRequest::set_allocated_content_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.content_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.content_id_.IsDefault()) {
          _impl_.content_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:shaka.CommonEncryptionRequest.content_id)
}

// optional string policy = 2;
inline bool CommonEncryptionRequest::has_policy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommonEncryptionRequest::clear_policy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.policy_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommonEncryptionRequest::policy() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.CommonEncryptionRequest.policy)
  return _internal_policy();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommonEncryptionRequest::set_policy(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.policy_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.CommonEncryptionRequest.policy)
}
inline std::string* CommonEncryptionRequest::mutable_policy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_policy();
  // @@protoc_insertion_point(field_mutable:shaka.CommonEncryptionRequest.policy)
  return _s;
}
inline const std::string& CommonEncryptionRequest::_internal_policy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.policy_.Get();
}
inline void CommonEncryptionRequest::_internal_set_policy(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.policy_.Set(value, GetArena());
}
inline std::string* CommonEncryptionRequest::_internal_mutable_policy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.policy_.Mutable( GetArena());
}
inline std::string* CommonEncryptionRequest::release_policy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.CommonEncryptionRequest.policy)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.policy_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.policy_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommonEncryptionRequest::set_allocated_policy(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.policy_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.policy_.IsDefault()) {
          _impl_.policy_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:shaka.CommonEncryptionRequest.policy)
}

// repeated .shaka.CommonEncryptionRequest.Track tracks = 3;
inline int CommonEncryptionRequest::_internal_tracks_size() const {
  return _internal_tracks().size();
}
inline int CommonEncryptionRequest::tracks_size() const {
  return _internal_tracks_size();
}
inline void CommonEncryptionRequest::clear_tracks() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tracks_.Clear();
}
inline ::shaka::CommonEncryptionRequest_Track* CommonEncryptionRequest::mutable_tracks(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:shaka.CommonEncryptionRequest.tracks)
  return _internal_mutable_tracks()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::shaka::CommonEncryptionRequest_Track>* CommonEncryptionRequest::mutable_tracks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:shaka.CommonEncryptionRequest.tracks)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tracks();
}
inline const ::shaka::CommonEncryptionRequest_Track& CommonEncryptionRequest::tracks(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.CommonEncryptionRequest.tracks)
  return _internal_tracks().Get(index);
}
inline ::shaka::CommonEncryptionRequest_Track* CommonEncryptionRequest::add_tracks() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::shaka::CommonEncryptionRequest_Track* _add = _internal_mutable_tracks()->Add();
  // @@protoc_insertion_point(field_add:shaka.CommonEncryptionRequest.tracks)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::shaka::CommonEncryptionRequest_Track>& CommonEncryptionRequest::tracks() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:shaka.CommonEncryptionRequest.tracks)
  return _internal_tracks();
}
inline const ::google::protobuf::RepeatedPtrField<::shaka::CommonEncryptionRequest_Track>&
CommonEncryptionRequest::_internal_tracks() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tracks_;
}
inline ::google::protobuf::RepeatedPtrField<::shaka::CommonEncryptionRequest_Track>*
CommonEncryptionRequest::_internal_mutable_tracks() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tracks_;
}

// repeated .shaka.ModularDrmType drm_types = 4;
inline int CommonEncryptionRequest::_internal_drm_types_size() const {
  return _internal_drm_types().size();
}
inline int CommonEncryptionRequest::drm_types_size() const {
  return _internal_drm_types_size();
}
inline void CommonEncryptionRequest::clear_drm_types() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.drm_types_.Clear();
}
inline ::shaka::ModularDrmType CommonEncryptionRequest::drm_types(int index) const {
  // @@protoc_insertion_point(field_get:shaka.CommonEncryptionRequest.drm_types)
  return static_cast<::shaka::ModularDrmType>(_internal_drm_types().Get(index));
}
inline void CommonEncryptionRequest::set_drm_types(int index, ::shaka::ModularDrmType value) {
  assert(::shaka::ModularDrmType_IsValid(value));
  _internal_mutable_drm_types()->Set(index, value);
  // @@protoc_insertion_point(field_set:shaka.CommonEncryptionRequest.drm_types)
}
inline void CommonEncryptionRequest::add_drm_types(::shaka::ModularDrmType value) {
  assert(::shaka::ModularDrmType_IsValid(value));
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_drm_types()->Add(value);
  // @@protoc_insertion_point(field_add:shaka.CommonEncryptionRequest.drm_types)
}
inline const ::google::protobuf::RepeatedField<int>& CommonEncryptionRequest::drm_types() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:shaka.CommonEncryptionRequest.drm_types)
  return _internal_drm_types();
}
inline ::google::protobuf::RepeatedField<int>* CommonEncryptionRequest::mutable_drm_types()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:shaka.CommonEncryptionRequest.drm_types)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_drm_types();
}
inline const ::google::protobuf::RepeatedField<int>& CommonEncryptionRequest::_internal_drm_types() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.drm_types_;
}
inline ::google::protobuf::RepeatedField<int>* CommonEncryptionRequest::_internal_mutable_drm_types() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.drm_types_;
}

// optional uint32 first_crypto_period_index = 8;
inline bool CommonEncryptionRequest::has_first_crypto_period_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void CommonEncryptionRequest::clear_first_crypto_period_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.first_crypto_period_index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint32_t CommonEncryptionRequest::first_crypto_period_index() const {
  // @@protoc_insertion_point(field_get:shaka.CommonEncryptionRequest.first_crypto_period_index)
  return _internal_first_crypto_period_index();
}
inline void CommonEncryptionRequest::set_first_crypto_period_index(::uint32_t value) {
  _internal_set_first_crypto_period_index(value);
  // @@protoc_insertion_point(field_set:shaka.CommonEncryptionRequest.first_crypto_period_index)
}
inline ::uint32_t CommonEncryptionRequest::_internal_first_crypto_period_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.first_crypto_period_index_;
}
inline void CommonEncryptionRequest::_internal_set_first_crypto_period_index(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.first_crypto_period_index_ = value;
}

// optional uint32 crypto_period_count = 9 [default = 1];
inline bool CommonEncryptionRequest::has_crypto_period_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void CommonEncryptionRequest::clear_crypto_period_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.crypto_period_count_ = 1u;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::uint32_t CommonEncryptionRequest::crypto_period_count() const {
  // @@protoc_insertion_point(field_get:shaka.CommonEncryptionRequest.crypto_period_count)
  return _internal_crypto_period_count();
}
inline void CommonEncryptionRequest::set_crypto_period_count(::uint32_t value) {
  _internal_set_crypto_period_count(value);
  // @@protoc_insertion_point(field_set:shaka.CommonEncryptionRequest.crypto_period_count)
}
inline ::uint32_t CommonEncryptionRequest::_internal_crypto_period_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.crypto_period_count_;
}
inline void CommonEncryptionRequest::_internal_set_crypto_period_count(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.crypto_period_count_ = value;
}

// optional bytes pssh_data = 10;
inline bool CommonEncryptionRequest::has_pssh_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommonEncryptionRequest::clear_pssh_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pssh_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CommonEncryptionRequest::pssh_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.CommonEncryptionRequest.pssh_data)
  return _internal_pssh_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommonEncryptionRequest::set_pssh_data(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.pssh_data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.CommonEncryptionRequest.pssh_data)
}
inline std::string* CommonEncryptionRequest::mutable_pssh_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_pssh_data();
  // @@protoc_insertion_point(field_mutable:shaka.CommonEncryptionRequest.pssh_data)
  return _s;
}
inline const std::string& CommonEncryptionRequest::_internal_pssh_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pssh_data_.Get();
}
inline void CommonEncryptionRequest::_internal_set_pssh_data(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.pssh_data_.Set(value, GetArena());
}
inline std::string* CommonEncryptionRequest::_internal_mutable_pssh_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.pssh_data_.Mutable( GetArena());
}
inline std::string* CommonEncryptionRequest::release_pssh_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.CommonEncryptionRequest.pssh_data)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.pssh_data_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.pssh_data_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommonEncryptionRequest::set_allocated_pssh_data(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.pssh_data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.pssh_data_.IsDefault()) {
          _impl_.pssh_data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:shaka.CommonEncryptionRequest.pssh_data)
}

// optional uint32 asset_id = 11;
inline bool CommonEncryptionRequest::has_asset_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void CommonEncryptionRequest::clear_asset_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.asset_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint32_t CommonEncryptionRequest::asset_id() const {
  // @@protoc_insertion_point(field_get:shaka.CommonEncryptionRequest.asset_id)
  return _internal_asset_id();
}
inline void CommonEncryptionRequest::set_asset_id(::uint32_t value) {
  _internal_set_asset_id(value);
  // @@protoc_insertion_point(field_set:shaka.CommonEncryptionRequest.asset_id)
}
inline ::uint32_t CommonEncryptionRequest::_internal_asset_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.asset_id_;
}
inline void CommonEncryptionRequest::_internal_set_asset_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.asset_id_ = value;
}

// optional bytes group_id = 12;
inline bool CommonEncryptionRequest::has_group_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CommonEncryptionRequest::clear_group_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.group_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CommonEncryptionRequest::group_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.CommonEncryptionRequest.group_id)
  return _internal_group_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommonEncryptionRequest::set_group_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.group_id_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.CommonEncryptionRequest.group_id)
}
inline std::string* CommonEncryptionRequest::mutable_group_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_group_id();
  // @@protoc_insertion_point(field_mutable:shaka.CommonEncryptionRequest.group_id)
  return _s;
}
inline const std::string& CommonEncryptionRequest::_internal_group_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.group_id_.Get();
}
inline void CommonEncryptionRequest::_internal_set_group_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.group_id_.Set(value, GetArena());
}
inline std::string* CommonEncryptionRequest::_internal_mutable_group_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.group_id_.Mutable( GetArena());
}
inline std::string* CommonEncryptionRequest::release_group_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.CommonEncryptionRequest.group_id)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.group_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.group_id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommonEncryptionRequest::set_allocated_group_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.group_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.group_id_.IsDefault()) {
          _impl_.group_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:shaka.CommonEncryptionRequest.group_id)
}

// optional uint32 crypto_period_seconds = 13;
inline bool CommonEncryptionRequest::has_crypto_period_seconds() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void CommonEncryptionRequest::clear_crypto_period_seconds() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.crypto_period_seconds_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::uint32_t CommonEncryptionRequest::crypto_period_seconds() const {
  // @@protoc_insertion_point(field_get:shaka.CommonEncryptionRequest.crypto_period_seconds)
  return _internal_crypto_period_seconds();
}
inline void CommonEncryptionRequest::set_crypto_period_seconds(::uint32_t value) {
  _internal_set_crypto_period_seconds(value);
  // @@protoc_insertion_point(field_set:shaka.CommonEncryptionRequest.crypto_period_seconds)
}
inline ::uint32_t CommonEncryptionRequest::_internal_crypto_period_seconds() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.crypto_period_seconds_;
}
inline void CommonEncryptionRequest::_internal_set_crypto_period_seconds(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.crypto_period_seconds_ = value;
}

// optional .shaka.CommonEncryptionRequest.ProtectionScheme protection_scheme = 14;
inline bool CommonEncryptionRequest::has_protection_scheme() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void CommonEncryptionRequest::clear_protection_scheme() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.protection_scheme_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::shaka::CommonEncryptionRequest_ProtectionScheme CommonEncryptionRequest::protection_scheme() const {
  // @@protoc_insertion_point(field_get:shaka.CommonEncryptionRequest.protection_scheme)
  return _internal_protection_scheme();
}
inline void CommonEncryptionRequest::set_protection_scheme(::shaka::CommonEncryptionRequest_ProtectionScheme value) {
  _internal_set_protection_scheme(value);
  // @@protoc_insertion_point(field_set:shaka.CommonEncryptionRequest.protection_scheme)
}
inline ::shaka::CommonEncryptionRequest_ProtectionScheme CommonEncryptionRequest::_internal_protection_scheme() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::shaka::CommonEncryptionRequest_ProtectionScheme>(_impl_.protection_scheme_);
}
inline void CommonEncryptionRequest::_internal_set_protection_scheme(::shaka::CommonEncryptionRequest_ProtectionScheme value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::shaka::CommonEncryptionRequest_ProtectionScheme_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.protection_scheme_ = value;
}

// optional bool enable_entitlement_license = 16;
inline bool CommonEncryptionRequest::has_enable_entitlement_license() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void CommonEncryptionRequest::clear_enable_entitlement_license() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.enable_entitlement_license_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool CommonEncryptionRequest::enable_entitlement_license() const {
  // @@protoc_insertion_point(field_get:shaka.CommonEncryptionRequest.enable_entitlement_license)
  return _internal_enable_entitlement_license();
}
inline void CommonEncryptionRequest::set_enable_entitlement_license(bool value) {
  _internal_set_enable_entitlement_license(value);
  // @@protoc_insertion_point(field_set:shaka.CommonEncryptionRequest.enable_entitlement_license)
}
inline bool CommonEncryptionRequest::_internal_enable_entitlement_license() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enable_entitlement_license_;
}
inline void CommonEncryptionRequest::_internal_set_enable_entitlement_license(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.enable_entitlement_license_ = value;
}

// optional string video_feature = 19;
inline bool CommonEncryptionRequest::has_video_feature() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void CommonEncryptionRequest::clear_video_feature() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.video_feature_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CommonEncryptionRequest::video_feature() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.CommonEncryptionRequest.video_feature)
  return _internal_video_feature();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommonEncryptionRequest::set_video_feature(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.video_feature_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.CommonEncryptionRequest.video_feature)
}
inline std::string* CommonEncryptionRequest::mutable_video_feature() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_video_feature();
  // @@protoc_insertion_point(field_mutable:shaka.CommonEncryptionRequest.video_feature)
  return _s;
}
inline const std::string& CommonEncryptionRequest::_internal_video_feature() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.video_feature_.Get();
}
inline void CommonEncryptionRequest::_internal_set_video_feature(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.video_feature_.Set(value, GetArena());
}
inline std::string* CommonEncryptionRequest::_internal_mutable_video_feature() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.video_feature_.Mutable( GetArena());
}
inline std::string* CommonEncryptionRequest::release_video_feature() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.CommonEncryptionRequest.video_feature)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.video_feature_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.video_feature_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommonEncryptionRequest::set_allocated_video_feature(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.video_feature_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.video_feature_.IsDefault()) {
          _impl_.video_feature_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:shaka.CommonEncryptionRequest.video_feature)
}

// -------------------------------------------------------------------

// CommonEncryptionResponse_Drm

// optional .shaka.ModularDrmType type = 1;
inline bool CommonEncryptionResponse_Drm::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommonEncryptionResponse_Drm::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::shaka::ModularDrmType CommonEncryptionResponse_Drm::type() const {
  // @@protoc_insertion_point(field_get:shaka.CommonEncryptionResponse.Drm.type)
  return _internal_type();
}
inline void CommonEncryptionResponse_Drm::set_type(::shaka::ModularDrmType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:shaka.CommonEncryptionResponse.Drm.type)
}
inline ::shaka::ModularDrmType CommonEncryptionResponse_Drm::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::shaka::ModularDrmType>(_impl_.type_);
}
inline void CommonEncryptionResponse_Drm::_internal_set_type(::shaka::ModularDrmType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::shaka::ModularDrmType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}

// optional string system_id = 2;
inline bool CommonEncryptionResponse_Drm::has_system_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommonEncryptionResponse_Drm::clear_system_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.system_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommonEncryptionResponse_Drm::system_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.CommonEncryptionResponse.Drm.system_id)
  return _internal_system_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommonEncryptionResponse_Drm::set_system_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.system_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.CommonEncryptionResponse.Drm.system_id)
}
inline std::string* CommonEncryptionResponse_Drm::mutable_system_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_system_id();
  // @@protoc_insertion_point(field_mutable:shaka.CommonEncryptionResponse.Drm.system_id)
  return _s;
}
inline const std::string& CommonEncryptionResponse_Drm::_internal_system_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.system_id_.Get();
}
inline void CommonEncryptionResponse_Drm::_internal_set_system_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.system_id_.Set(value, GetArena());
}
inline std::string* CommonEncryptionResponse_Drm::_internal_mutable_system_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.system_id_.Mutable( GetArena());
}
inline std::string* CommonEncryptionResponse_Drm::release_system_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.CommonEncryptionResponse.Drm.system_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.system_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.system_id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommonEncryptionResponse_Drm::set_allocated_system_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.system_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.system_id_.IsDefault()) {
          _impl_.system_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:shaka.CommonEncryptionResponse.Drm.system_id)
}

// -------------------------------------------------------------------

// CommonEncryptionResponse_Track_Pssh

// optional .shaka.ModularDrmType drm_type = 1;
inline bool CommonEncryptionResponse_Track_Pssh::has_drm_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommonEncryptionResponse_Track_Pssh::clear_drm_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.drm_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::shaka::ModularDrmType CommonEncryptionResponse_Track_Pssh::drm_type() const {
  // @@protoc_insertion_point(field_get:shaka.CommonEncryptionResponse.Track.Pssh.drm_type)
  return _internal_drm_type();
}
inline void CommonEncryptionResponse_Track_Pssh::set_drm_type(::shaka::ModularDrmType value) {
  _internal_set_drm_type(value);
  // @@protoc_insertion_point(field_set:shaka.CommonEncryptionResponse.Track.Pssh.drm_type)
}
inline ::shaka::ModularDrmType CommonEncryptionResponse_Track_Pssh::_internal_drm_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::shaka::ModularDrmType>(_impl_.drm_type_);
}
inline void CommonEncryptionResponse_Track_Pssh::_internal_set_drm_type(::shaka::ModularDrmType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::shaka::ModularDrmType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.drm_type_ = value;
}

// optional bytes data = 2;
inline bool CommonEncryptionResponse_Track_Pssh::has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommonEncryptionResponse_Track_Pssh::clear_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommonEncryptionResponse_Track_Pssh::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.CommonEncryptionResponse.Track.Pssh.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommonEncryptionResponse_Track_Pssh::set_data(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.CommonEncryptionResponse.Track.Pssh.data)
}
inline std::string* CommonEncryptionResponse_Track_Pssh::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:shaka.CommonEncryptionResponse.Track.Pssh.data)
  return _s;
}
inline const std::string& CommonEncryptionResponse_Track_Pssh::_internal_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_.Get();
}
inline void CommonEncryptionResponse_Track_Pssh::_internal_set_data(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_.Set(value, GetArena());
}
inline std::string* CommonEncryptionResponse_Track_Pssh::_internal_mutable_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.data_.Mutable( GetArena());
}
inline std::string* CommonEncryptionResponse_Track_Pssh::release_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.CommonEncryptionResponse.Track.Pssh.data)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.data_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.data_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommonEncryptionResponse_Track_Pssh::set_allocated_data(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_.IsDefault()) {
          _impl_.data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:shaka.CommonEncryptionResponse.Track.Pssh.data)
}

// optional bytes boxes = 3;
inline bool CommonEncryptionResponse_Track_Pssh::has_boxes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommonEncryptionResponse_Track_Pssh::clear_boxes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.boxes_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommonEncryptionResponse_Track_Pssh::boxes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.CommonEncryptionResponse.Track.Pssh.boxes)
  return _internal_boxes();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommonEncryptionResponse_Track_Pssh::set_boxes(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.boxes_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.CommonEncryptionResponse.Track.Pssh.boxes)
}
inline std::string* CommonEncryptionResponse_Track_Pssh::mutable_boxes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_boxes();
  // @@protoc_insertion_point(field_mutable:shaka.CommonEncryptionResponse.Track.Pssh.boxes)
  return _s;
}
inline const std::string& CommonEncryptionResponse_Track_Pssh::_internal_boxes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.boxes_.Get();
}
inline void CommonEncryptionResponse_Track_Pssh::_internal_set_boxes(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.boxes_.Set(value, GetArena());
}
inline std::string* CommonEncryptionResponse_Track_Pssh::_internal_mutable_boxes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.boxes_.Mutable( GetArena());
}
inline std::string* CommonEncryptionResponse_Track_Pssh::release_boxes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.CommonEncryptionResponse.Track.Pssh.boxes)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.boxes_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.boxes_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommonEncryptionResponse_Track_Pssh::set_allocated_boxes(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.boxes_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.boxes_.IsDefault()) {
          _impl_.boxes_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:shaka.CommonEncryptionResponse.Track.Pssh.boxes)
}

// -------------------------------------------------------------------

// CommonEncryptionResponse_Track

// optional string type = 1;
inline bool CommonEncryptionResponse_Track::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommonEncryptionResponse_Track::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommonEncryptionResponse_Track::type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.CommonEncryptionResponse.Track.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommonEncryptionResponse_Track::set_type(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.CommonEncryptionResponse.Track.type)
}
inline std::string* CommonEncryptionResponse_Track::mutable_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:shaka.CommonEncryptionResponse.Track.type)
  return _s;
}
inline const std::string& CommonEncryptionResponse_Track::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_.Get();
}
inline void CommonEncryptionResponse_Track::_internal_set_type(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_.Set(value, GetArena());
}
inline std::string* CommonEncryptionResponse_Track::_internal_mutable_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.type_.Mutable( GetArena());
}
inline std::string* CommonEncryptionResponse_Track::release_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.CommonEncryptionResponse.Track.type)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.type_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.type_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommonEncryptionResponse_Track::set_allocated_type(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.type_.IsDefault()) {
          _impl_.type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:shaka.CommonEncryptionResponse.Track.type)
}

// optional bytes key_id = 2;
inline bool CommonEncryptionResponse_Track::has_key_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommonEncryptionResponse_Track::clear_key_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommonEncryptionResponse_Track::key_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.CommonEncryptionResponse.Track.key_id)
  return _internal_key_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommonEncryptionResponse_Track::set_key_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.key_id_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.CommonEncryptionResponse.Track.key_id)
}
inline std::string* CommonEncryptionResponse_Track::mutable_key_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key_id();
  // @@protoc_insertion_point(field_mutable:shaka.CommonEncryptionResponse.Track.key_id)
  return _s;
}
inline const std::string& CommonEncryptionResponse_Track::_internal_key_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_id_.Get();
}
inline void CommonEncryptionResponse_Track::_internal_set_key_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.key_id_.Set(value, GetArena());
}
inline std::string* CommonEncryptionResponse_Track::_internal_mutable_key_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.key_id_.Mutable( GetArena());
}
inline std::string* CommonEncryptionResponse_Track::release_key_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.CommonEncryptionResponse.Track.key_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.key_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.key_id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommonEncryptionResponse_Track::set_allocated_key_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.key_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_id_.IsDefault()) {
          _impl_.key_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:shaka.CommonEncryptionResponse.Track.key_id)
}

// optional bytes key = 3;
inline bool CommonEncryptionResponse_Track::has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommonEncryptionResponse_Track::clear_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CommonEncryptionResponse_Track::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.CommonEncryptionResponse.Track.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommonEncryptionResponse_Track::set_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.CommonEncryptionResponse.Track.key)
}
inline std::string* CommonEncryptionResponse_Track::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:shaka.CommonEncryptionResponse.Track.key)
  return _s;
}
inline const std::string& CommonEncryptionResponse_Track::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_.Get();
}
inline void CommonEncryptionResponse_Track::_internal_set_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.key_.Set(value, GetArena());
}
inline std::string* CommonEncryptionResponse_Track::_internal_mutable_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* CommonEncryptionResponse_Track::release_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.CommonEncryptionResponse.Track.key)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.key_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.key_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommonEncryptionResponse_Track::set_allocated_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:shaka.CommonEncryptionResponse.Track.key)
}

// optional bytes iv = 4;
inline bool CommonEncryptionResponse_Track::has_iv() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CommonEncryptionResponse_Track::clear_iv() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.iv_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CommonEncryptionResponse_Track::iv() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.CommonEncryptionResponse.Track.iv)
  return _internal_iv();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommonEncryptionResponse_Track::set_iv(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.iv_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.CommonEncryptionResponse.Track.iv)
}
inline std::string* CommonEncryptionResponse_Track::mutable_iv() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_iv();
  // @@protoc_insertion_point(field_mutable:shaka.CommonEncryptionResponse.Track.iv)
  return _s;
}
inline const std::string& CommonEncryptionResponse_Track::_internal_iv() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.iv_.Get();
}
inline void CommonEncryptionResponse_Track::_internal_set_iv(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.iv_.Set(value, GetArena());
}
inline std::string* CommonEncryptionResponse_Track::_internal_mutable_iv() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.iv_.Mutable( GetArena());
}
inline std::string* CommonEncryptionResponse_Track::release_iv() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.CommonEncryptionResponse.Track.iv)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.iv_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.iv_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommonEncryptionResponse_Track::set_allocated_iv(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.iv_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.iv_.IsDefault()) {
          _impl_.iv_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:shaka.CommonEncryptionResponse.Track.iv)
}

// repeated .shaka.CommonEncryptionResponse.Track.Pssh pssh = 5;
inline int CommonEncryptionResponse_Track::_internal_pssh_size() const {
  return _internal_pssh().size();
}
inline int CommonEncryptionResponse_Track::pssh_size() const {
  return _internal_pssh_size();
}
inline void CommonEncryptionResponse_Track::clear_pssh() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pssh_.Clear();
}
inline ::shaka::CommonEncryptionResponse_Track_Pssh* CommonEncryptionResponse_Track::mutable_pssh(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:shaka.CommonEncryptionResponse.Track.pssh)
  return _internal_mutable_pssh()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::shaka::CommonEncryptionResponse_Track_Pssh>* CommonEncryptionResponse_Track::mutable_pssh()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:shaka.CommonEncryptionResponse.Track.pssh)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_pssh();
}
inline const ::shaka::CommonEncryptionResponse_Track_Pssh& CommonEncryptionResponse_Track::pssh(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.CommonEncryptionResponse.Track.pssh)
  return _internal_pssh().Get(index);
}
inline ::shaka::CommonEncryptionResponse_Track_Pssh* CommonEncryptionResponse_Track::add_pssh() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::shaka::CommonEncryptionResponse_Track_Pssh* _add = _internal_mutable_pssh()->Add();
  // @@protoc_insertion_point(field_add:shaka.CommonEncryptionResponse.Track.pssh)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::shaka::CommonEncryptionResponse_Track_Pssh>& CommonEncryptionResponse_Track::pssh() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:shaka.CommonEncryptionResponse.Track.pssh)
  return _internal_pssh();
}
inline const ::google::protobuf::RepeatedPtrField<::shaka::CommonEncryptionResponse_Track_Pssh>&
CommonEncryptionResponse_Track::_internal_pssh() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pssh_;
}
inline ::google::protobuf::RepeatedPtrField<::shaka::CommonEncryptionResponse_Track_Pssh>*
CommonEncryptionResponse_Track::_internal_mutable_pssh() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.pssh_;
}

// optional uint32 crypto_period_index = 6;
inline bool CommonEncryptionResponse_Track::has_crypto_period_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void CommonEncryptionResponse_Track::clear_crypto_period_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.crypto_period_index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t CommonEncryptionResponse_Track::crypto_period_index() const {
  // @@protoc_insertion_point(field_get:shaka.CommonEncryptionResponse.Track.crypto_period_index)
  return _internal_crypto_period_index();
}
inline void CommonEncryptionResponse_Track::set_crypto_period_index(::uint32_t value) {
  _internal_set_crypto_period_index(value);
  // @@protoc_insertion_point(field_set:shaka.CommonEncryptionResponse.Track.crypto_period_index)
}
inline ::uint32_t CommonEncryptionResponse_Track::_internal_crypto_period_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.crypto_period_index_;
}
inline void CommonEncryptionResponse_Track::_internal_set_crypto_period_index(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.crypto_period_index_ = value;
}

// -------------------------------------------------------------------

// CommonEncryptionResponse

// optional .shaka.CommonEncryptionResponse.Status status = 1;
inline bool CommonEncryptionResponse::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommonEncryptionResponse::clear_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::shaka::CommonEncryptionResponse_Status CommonEncryptionResponse::status() const {
  // @@protoc_insertion_point(field_get:shaka.CommonEncryptionResponse.status)
  return _internal_status();
}
inline void CommonEncryptionResponse::set_status(::shaka::CommonEncryptionResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:shaka.CommonEncryptionResponse.status)
}
inline ::shaka::CommonEncryptionResponse_Status CommonEncryptionResponse::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::shaka::CommonEncryptionResponse_Status>(_impl_.status_);
}
inline void CommonEncryptionResponse::_internal_set_status(::shaka::CommonEncryptionResponse_Status value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::shaka::CommonEncryptionResponse_Status_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.status_ = value;
}

// repeated .shaka.CommonEncryptionResponse.Drm drm = 3;
inline int CommonEncryptionResponse::_internal_drm_size() const {
  return _internal_drm().size();
}
inline int CommonEncryptionResponse::drm_size() const {
  return _internal_drm_size();
}
inline void CommonEncryptionResponse::clear_drm() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.drm_.Clear();
}
inline ::shaka::CommonEncryptionResponse_Drm* CommonEncryptionResponse::mutable_drm(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:shaka.CommonEncryptionResponse.drm)
  return _internal_mutable_drm()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::shaka::CommonEncryptionResponse_Drm>* CommonEncryptionResponse::mutable_drm()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:shaka.CommonEncryptionResponse.drm)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_drm();
}
inline const ::shaka::CommonEncryptionResponse_Drm& CommonEncryptionResponse::drm(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.CommonEncryptionResponse.drm)
  return _internal_drm().Get(index);
}
inline ::shaka::CommonEncryptionResponse_Drm* CommonEncryptionResponse::add_drm() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::shaka::CommonEncryptionResponse_Drm* _add = _internal_mutable_drm()->Add();
  // @@protoc_insertion_point(field_add:shaka.CommonEncryptionResponse.drm)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::shaka::CommonEncryptionResponse_Drm>& CommonEncryptionResponse::drm() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:shaka.CommonEncryptionResponse.drm)
  return _internal_drm();
}
inline const ::google::protobuf::RepeatedPtrField<::shaka::CommonEncryptionResponse_Drm>&
CommonEncryptionResponse::_internal_drm() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.drm_;
}
inline ::google::protobuf::RepeatedPtrField<::shaka::CommonEncryptionResponse_Drm>*
CommonEncryptionResponse::_internal_mutable_drm() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.drm_;
}

// repeated .shaka.CommonEncryptionResponse.Track tracks = 4;
inline int CommonEncryptionResponse::_internal_tracks_size() const {
  return _internal_tracks().size();
}
inline int CommonEncryptionResponse::tracks_size() const {
  return _internal_tracks_size();
}
inline void CommonEncryptionResponse::clear_tracks() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tracks_.Clear();
}
inline ::shaka::CommonEncryptionResponse_Track* CommonEncryptionResponse::mutable_tracks(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:shaka.CommonEncryptionResponse.tracks)
  return _internal_mutable_tracks()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::shaka::CommonEncryptionResponse_Track>* CommonEncryptionResponse::mutable_tracks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:shaka.CommonEncryptionResponse.tracks)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tracks();
}
inline const ::shaka::CommonEncryptionResponse_Track& CommonEncryptionResponse::tracks(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.CommonEncryptionResponse.tracks)
  return _internal_tracks().Get(index);
}
inline ::shaka::CommonEncryptionResponse_Track* CommonEncryptionResponse::add_tracks() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::shaka::CommonEncryptionResponse_Track* _add = _internal_mutable_tracks()->Add();
  // @@protoc_insertion_point(field_add:shaka.CommonEncryptionResponse.tracks)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::shaka::CommonEncryptionResponse_Track>& CommonEncryptionResponse::tracks() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:shaka.CommonEncryptionResponse.tracks)
  return _internal_tracks();
}
inline const ::google::protobuf::RepeatedPtrField<::shaka::CommonEncryptionResponse_Track>&
CommonEncryptionResponse::_internal_tracks() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tracks_;
}
inline ::google::protobuf::RepeatedPtrField<::shaka::CommonEncryptionResponse_Track>*
CommonEncryptionResponse::_internal_mutable_tracks() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tracks_;
}

// optional bytes content_id = 6;
inline bool CommonEncryptionResponse::has_content_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommonEncryptionResponse::clear_content_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.content_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommonEncryptionResponse::content_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.CommonEncryptionResponse.content_id)
  return _internal_content_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommonEncryptionResponse::set_content_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.content_id_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.CommonEncryptionResponse.content_id)
}
inline std::string* CommonEncryptionResponse::mutable_content_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_content_id();
  // @@protoc_insertion_point(field_mutable:shaka.CommonEncryptionResponse.content_id)
  return _s;
}
inline const std::string& CommonEncryptionResponse::_internal_content_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.content_id_.Get();
}
inline void CommonEncryptionResponse::_internal_set_content_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.content_id_.Set(value, GetArena());
}
inline std::string* CommonEncryptionResponse::_internal_mutable_content_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.content_id_.Mutable( GetArena());
}
inline std::string* CommonEncryptionResponse::release_content_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.CommonEncryptionResponse.content_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.content_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.content_id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommonEncryptionResponse::set_allocated_content_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.content_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.content_id_.IsDefault()) {
          _impl_.content_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:shaka.CommonEncryptionResponse.content_id)
}

// -------------------------------------------------------------------

// SignedModularDrmRequest

// optional bytes request = 1;
inline bool SignedModularDrmRequest::has_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SignedModularDrmRequest::clear_request() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SignedModularDrmRequest::request() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.SignedModularDrmRequest.request)
  return _internal_request();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SignedModularDrmRequest::set_request(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.request_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.SignedModularDrmRequest.request)
}
inline std::string* SignedModularDrmRequest::mutable_request() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:shaka.SignedModularDrmRequest.request)
  return _s;
}
inline const std::string& SignedModularDrmRequest::_internal_request() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_.Get();
}
inline void SignedModularDrmRequest::_internal_set_request(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.request_.Set(value, GetArena());
}
inline std::string* SignedModularDrmRequest::_internal_mutable_request() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.request_.Mutable( GetArena());
}
inline std::string* SignedModularDrmRequest::release_request() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.SignedModularDrmRequest.request)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.request_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.request_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SignedModularDrmRequest::set_allocated_request(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.request_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.request_.IsDefault()) {
          _impl_.request_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:shaka.SignedModularDrmRequest.request)
}

// optional bytes signature = 2;
inline bool SignedModularDrmRequest::has_signature() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SignedModularDrmRequest::clear_signature() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.signature_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SignedModularDrmRequest::signature() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.SignedModularDrmRequest.signature)
  return _internal_signature();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SignedModularDrmRequest::set_signature(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.signature_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.SignedModularDrmRequest.signature)
}
inline std::string* SignedModularDrmRequest::mutable_signature() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:shaka.SignedModularDrmRequest.signature)
  return _s;
}
inline const std::string& SignedModularDrmRequest::_internal_signature() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.signature_.Get();
}
inline void SignedModularDrmRequest::_internal_set_signature(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.signature_.Set(value, GetArena());
}
inline std::string* SignedModularDrmRequest::_internal_mutable_signature() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.signature_.Mutable( GetArena());
}
inline std::string* SignedModularDrmRequest::release_signature() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.SignedModularDrmRequest.signature)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.signature_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.signature_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SignedModularDrmRequest::set_allocated_signature(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.signature_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.signature_.IsDefault()) {
          _impl_.signature_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:shaka.SignedModularDrmRequest.signature)
}

// optional string signer = 3;
inline bool SignedModularDrmRequest::has_signer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SignedModularDrmRequest::clear_signer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.signer_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SignedModularDrmRequest::signer() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.SignedModularDrmRequest.signer)
  return _internal_signer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SignedModularDrmRequest::set_signer(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.signer_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.SignedModularDrmRequest.signer)
}
inline std::string* SignedModularDrmRequest::mutable_signer() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_signer();
  // @@protoc_insertion_point(field_mutable:shaka.SignedModularDrmRequest.signer)
  return _s;
}
inline const std::string& SignedModularDrmRequest::_internal_signer() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.signer_.Get();
}
inline void SignedModularDrmRequest::_internal_set_signer(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.signer_.Set(value, GetArena());
}
inline std::string* SignedModularDrmRequest::_internal_mutable_signer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.signer_.Mutable( GetArena());
}
inline std::string* SignedModularDrmRequest::release_signer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.SignedModularDrmRequest.signer)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.signer_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.signer_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SignedModularDrmRequest::set_allocated_signer(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.signer_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.signer_.IsDefault()) {
          _impl_.signer_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:shaka.SignedModularDrmRequest.signer)
}

// -------------------------------------------------------------------

// SignedModularDrmResponse

// optional bytes response = 1;
inline bool SignedModularDrmResponse::has_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SignedModularDrmResponse::clear_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.response_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SignedModularDrmResponse::response() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.SignedModularDrmResponse.response)
  return _internal_response();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SignedModularDrmResponse::set_response(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.response_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.SignedModularDrmResponse.response)
}
inline std::string* SignedModularDrmResponse::mutable_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:shaka.SignedModularDrmResponse.response)
  return _s;
}
inline const std::string& SignedModularDrmResponse::_internal_response() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.response_.Get();
}
inline void SignedModularDrmResponse::_internal_set_response(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.response_.Set(value, GetArena());
}
inline std::string* SignedModularDrmResponse::_internal_mutable_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.response_.Mutable( GetArena());
}
inline std::string* SignedModularDrmResponse::release_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.SignedModularDrmResponse.response)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.response_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.response_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SignedModularDrmResponse::set_allocated_response(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.response_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.response_.IsDefault()) {
          _impl_.response_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:shaka.SignedModularDrmResponse.response)
}

// optional bytes signature = 2;
inline bool SignedModularDrmResponse::has_signature() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SignedModularDrmResponse::clear_signature() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.signature_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SignedModularDrmResponse::signature() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:shaka.SignedModularDrmResponse.signature)
  return _internal_signature();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SignedModularDrmResponse::set_signature(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.signature_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:shaka.SignedModularDrmResponse.signature)
}
inline std::string* SignedModularDrmResponse::mutable_signature() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:shaka.SignedModularDrmResponse.signature)
  return _s;
}
inline const std::string& SignedModularDrmResponse::_internal_signature() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.signature_.Get();
}
inline void SignedModularDrmResponse::_internal_set_signature(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.signature_.Set(value, GetArena());
}
inline std::string* SignedModularDrmResponse::_internal_mutable_signature() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.signature_.Mutable( GetArena());
}
inline std::string* SignedModularDrmResponse::release_signature() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:shaka.SignedModularDrmResponse.signature)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.signature_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.signature_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SignedModularDrmResponse::set_allocated_signature(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.signature_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.signature_.IsDefault()) {
          _impl_.signature_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:shaka.SignedModularDrmResponse.signature)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace shaka


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::shaka::CommonEncryptionRequest_ProtectionScheme> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::shaka::CommonEncryptionRequest_ProtectionScheme>() {
  return ::shaka::CommonEncryptionRequest_ProtectionScheme_descriptor();
}
template <>
struct is_proto_enum<::shaka::CommonEncryptionResponse_Status> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::shaka::CommonEncryptionResponse_Status>() {
  return ::shaka::CommonEncryptionResponse_Status_descriptor();
}
template <>
struct is_proto_enum<::shaka::ModularDrmType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::shaka::ModularDrmType>() {
  return ::shaka::ModularDrmType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_widevine_5fcommon_5fencryption_2eproto_2epb_2eh
